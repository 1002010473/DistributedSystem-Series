# Actor 模型

Smalltalk 的设计者、面向对象编程之父 Alan Kay 曾经这样描述面向对象的本质 ①：很久以前，我在描述“面向对象编程”时使用了“对象”这个概念。很抱歉这个概念让许多人误入歧途，他们将学习的重心放在了“对象”这个次要的方面。真正主要的方面是“消息”……日文中有一个词 ma，表示“间隔”，与其最为相近的英文或许是“

interstitial”。创建一个规模宏大且可生长的系统的关键在于其模块之间应该如何交流，而不在于其内部的属性和行为应该如何表现。这段话也概括了使用 actor 模型进行编程的精髓——我们可以认为 actor 模型是面向对象模型在并发编程领域的扩展。

actor 模型精心设计了消息传输和封装的机制，强调了面向对象的精髓，可以说 actor 模型非常“面向对象”。

**优点**

actor 有许多优良的特性，适用于解决多种并发问题。消息传输和封装虽然多个 actor 可以同时运行，但它们并不共享状态，而且在单个 actor 中所有事件都是串行执行的。所以关于并发，只需要关注于多个 actor 之间的消息流即可。

对开发人员来说这是个重大利好。每个 actor 可以被单独测试，而且当测试覆盖了某个 actor 的消息类型和消息顺序时，就可以确定这个 actor 非常可靠。如果发现了一个与并发相关的 bug，也就知道重点应该放在 actor 之间的消息流上。

**容错**

使用 actor 模型的程序天生具有容错性。这不仅会让程序更加强壮，而且(通过“任其崩溃”的哲学)会让代码更加简洁明了。

** 分布式编程**

actor 模型支持共享内存模型，也支持分布式内存模型，这就带来了很多优点。首先， actor 模型几乎可以解决任何规模的问题。我们不需要将问题局限于用一个系统解决。其次， actor 模型可以解决地理分布式问题。对于不同部分需要部署在不同地理位置的软件，Actor 模型是个极佳的选择。最后，分布式是软件具有容错能力的基石。

**缺点**

尽管使用 actor 模型的程序比使用线程与锁模型的程序更容易 debug，但 actor 模型仍会碰到死锁这一类的共性问题，也会碰到一些 actor 模型独有的问题(例如信箱溢出)。

类似于线程与锁模型， actor 模型对并行也没有提供直接支持。需要通过并发的技术来构造并行的方案，这样就会引入不确定性。而且，由于多个 actor 并不共享状态，仅通过消息传递来进行交流，所以不太适合实施细粒度的并行。

**其他语言**

与许多伟大的思想一样， actor 模型也由来悠久——20 世纪 70 年代 Carl Hewitt 首次提出这个模型。 Erlang 无疑为布道 actor 做了最大的贡献。比如 Erlang 的创始人 Joe Armstrong 也是“任其崩溃”哲学的先驱。大部分流行的编程语言都提供了一个 actor 库，特别是 Akka 库 ① 为 Java 和其他运行于 JVM 的语言提供了对 actor 模型的支持。如果想深入学习 Akka，建议阅读本书的奖励章节 ②，其中描述了如何用 Scala 进行 actor 编程。
