# 锁的实现

锁必须是原子性操作实现，决不能中途打断，由处理器原语支持。锁的意义在于将操作做为一个执行单元以一种原子方式执行而不被打断，多线程下也不会互相干扰。但是锁会影响性能，这是因为一个加锁的临界资源 在被访问前必须获取对应的锁，获取该锁的线程将以独占的方式访问临界区。如果此时有其他线程同时访问临界区，则会因为无法获取这个锁而阻塞，显然，在临界区强行通过加锁使线程执行串行化是需要牺牲一定的性能的。

# Semaphore | 信号量

信号量又称为信号灯，它是用来协调不同进程间的数据对象的，而最主要的应用是共享内存方式的进程间通信。本质上，信号量是一个计数器，它用来记录对某个资源(如共享内存)的存取状况。一般说来，为了获得共享资源，进程需要执行下列操作:

1. 测试控制该资源的信号量。
2. 若此信号量的值为正，则允许进行使用该资源。进程将信号量减 1。
3. 若此信号量为 0，则该资源目前不可用，进程进入睡眠状态，直至信号量值大于 0，进程被唤醒，转入步骤(1)。
4. 当进程不再使用一个信号量控制的资源时，信号量值加 1。如果此时有进程正在睡眠等待此信号量，则唤醒此进程。

信号量与普通整型变量的区别：

- 信号量(semaphore)是非负整型变量，除了初始化之外，它只能通过两个标准原子操作：wait(semap) , signal(semap) ; 来进行访问；
- 操作也被成为 PV 原语(P 来源于 Dutch proberen"测试"，V 来源于 Dutch verhogen"增加")，而普通整型变量则可以在任何语句块中被访问；
