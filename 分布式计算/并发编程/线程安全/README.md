# 线程安全

线程安全性是并发代码最重要也是最基本的要求，我们不应容忍大部分时候可以正确运行，但是在偶然情况下会出错的并发程序。多线程的核心矛盾即为**竞态条件**，即多个线程同时读写某个字段；而竞态条件下多线程争抢的资源就是**竞态资源**，或者说是**临界资源**。**临界区**即是设计读写竞态资源的代码片。上文已经提到，共享可变状态是造成线程不安全的唯一原因，那么为了解决线程安全性问题，可以先从避免共享状态或者避免可变状态入手。

所有的线程安全性问题，都可以归结于同一个原因: 共享的可变状态。首先来看状态的共享，在 Java 中，如果类的某个域被声明为 public，或者通过 public 方法返回了某个 private 域的引用，那么这个域就可以被其它对象访问到，可以认为基于该类创建的对象，共享了其状态。一旦状态被共享，宿主对象就失去了状态的完全控制权，你无法预知其它对象会对共享状态做怎样的误操作。状态的可变性问题则来源于我们将在内存模型章节讨论的可见性、原子性与有序性问题。

# 线程同步

每个进程中访问临界资源的那段程序称为临界区，临界资源是一次仅允许一个进程使用的共享资源。线程同步的核心在于，通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。在任意时刻只允许一个线程对共享资源进行访问，如果有多个线程试图访问公共资源，那么在有一个线程进入后，其他试图访问公共资源的线程将被挂起，并一直等到进入临界区的线程离开，临界区在被释放后，其他线程才可以抢占。

互斥量（Mutex），信号量（Semaphore），事件（Event）都可以被跨越进程使用来进行同步数据操作，而其他的对象与数据同步操作无关，但对于进程和线程来讲，如果进程和线程在运行状态则为无信号状态，在退出后为有信号状态。所以可以使用 WaitForSingleObject 来等待进程和线程退出。

## 临界资源与临界区

所谓的临界资源，即一次只允许一个进程访问的资源，多个进程只能互斥访问的资源。临界资源的访问需要同步操作，比如信号量就是一种方便有效的进程同步机制。但信号量的方式要求每个访问临界资源的进程都具有 wait 和 signal 操作。这样使大量的同步操作分散在各个进程中，不仅给系统管理带来了麻烦，而且会因同步操作的使用不当导致死锁。管程就是为了解决这样的问题而产生的。

操作系统中管理的各种软件和硬件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对该资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。利用共享数据结构抽象地表示系统中的共享资源。而把对该共享数据结构实施的操作定义为一组过程，如资源的请求和释放过程 request 和 release。进程对共享资源的申请、释放和其他操作，都是通过这组过程对共享数据结构的操作来实现的，这组过程还可以根据资源的情况接受或阻塞进程的访问，确保每次仅有一个进程使用该共享资源，这样就可以统一管理对共享资源的所有访问，实现临界资源互斥访问。

管程就是代表共享资源的数据结构以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序共同构成的一个操作系统的资源管理模块。管程被请求和释放临界资源的进程所调用。管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。

## 锁与互斥

互斥量与临界区的作用非常相似，但互斥量是可以命名的，也就是说它可以跨越进程使用。所以创建互斥量需要的资源更多，所以如果只为了在进程内部是用的话使用临界区会带来速度上的优势并能够减少资源占用量。因为互斥量是跨进程的互斥量一旦被创建，就可以通过名字打开它。

采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限，因为互斥对象只有一个，所以能保证公共资源不会同时被多个线程访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。互斥量比临界区复杂。因为使用互斥不仅仅能够在同一应用程序不同线程中实现资源的安全共享，而且可以在不同应用程序的线程之间实现对资源的安全共享。

如果共享和可变都无法避免，那么只有使用互斥/同步机制，来保证线程安全性。**互斥**是指某一资源同时只允许一个访问者对其进行访问，具有唯一性和排它性；但互斥无法限制访问者对资源的访问顺序，即访问是无序的。同步是指在互斥的基础上(大多数情况)，通过其它机制实现访问者对资源的有序访问。在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的；少数情况是指可以允许多个访问者同时访问资源。

```java
if(!occipied){ // 检查
    occupied = true; // 占锁
    critical_region(); // 临界区
    occupied = false; // 释放锁
}
```

最朴素的互斥手段，就是进入临界区之前，用 if 语句检查 bool 值，条件不满足就等待或者抛出异常；该值即为锁变量，不过该变量可能非线程安全，因为该动作不具备原子性。所谓的 TSL 指令，即是原子性地完成“检查-占锁”这个动作的指令。所谓的互斥量即是使用了 sleep 与 wakeup 原语，保证同一时刻只有一个线程进入临界区代码片段的锁。而将互斥锁推广到 N 维空间，同时允许有 N 个线程进入临界区的锁称为信号量。互斥量和信号量的实现都依赖于 TSL 指令保证“检查-占锁”动作的原子性。

管程即是从编译器的层面保证了临界区的互斥，譬如在 Java 代码中，通常使用 synchronized 关键字，对类或者对象加锁，来实现同步。被 synchronized 修饰的代码块及方法，在同一时间，只能被单个线程访问。synchronized 关键字以退化到单线程的方法，解决并发安全性的问题。

不使用 TSL 指令的另一种锁的方式称为自旋锁，但是自旋锁的缺点就是条件不满足时候会忙等待，需要后台调度器重新分配时间片，效率比较低。自旋锁的关键就是使用 while 轮询，代替 if 检查状态；这样就算线程切出去，另一个线程也会因为条件不满足循环忙等，不会进入临界区，我们常见的 `wait()`，`notifyAll()` 等条件变量都是基于此。

```java
// 线程 A
while(true){
    while(turn != 0){} // 锁被占用，循环忙等
    critical_region();
    turn = 1; // 释放锁
    noncritical_region();
}

// 线程 B
while(true){
    while(turn != 1){} // 锁被占，循环忙等
    critical_region();
    turn = 0; // 释放锁
    noncritical_region();
}
```

## 信号量（Semaphore）

它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。信号量对象对线程的同步方式与前面几种方法不同，信号允许多个线程同时使用共享资源，这与操作系统中的 PV 操作相同。它指出了同时访问共享资源的线程最大数目。它允许多个线程在同一时刻访问同一资源，但是需要限制在同一时刻访问此资源的最大线程数目。

通过互斥量可以指定资源被独占的方式使用，但如果有下面一种情况通过互斥量就无法处理，比如现在一位用户购买了一份三个并发访问许可的数据库系统，可以根据用户购买的访问许可数量来决定有多少个线程/进程能同时进行数据库操作，这时候如果利用互斥量就没有办法完成这个要求，信号量对象可以说是一种资源计数器。

## 事件（Event）

通过通知操作的方式来保持线程的同步，还可以方便实现对多个线程的优先级比较的操作。事件是用来在进程和线程间同步的。就像我们人之间的交流。我把一件事做完了，告诉别人，别人收到这个消息才能接着往下做。或者他还要等第三个人把事情做完才能开始做他的事。

# 避免共享的可变状态

避免共享状态理想的情况是构造无状态的程序，没有状态自然也就不会共享。一个典型的例子就是 Servlet 程序，各 Servlet 自身并不持有状态，彼此隔离，互不相扰。如果持有状态不可避免，则可以使用线程封闭技术，将状态'隐藏起来，不让别的线程访问到。常见的有栈封闭和 ThreadLocal 类两种形式。

## 栈封闭

栈封闭是线程封闭的一种特例，在栈封闭中，只能通过局部变量访问对象，这些局部变量被封闭在执行线程的栈内部，其它线程无法访问到它们。

```java
public int loadTheArk(Collection<Animal> candidates) {
    SortedSet<Animal> animals;
    int numPairs = 0;
    Animal candidate = null;

    // animals confined to method, don't let them escape!
    animals = new TreeSet<Animal>(new SpeciesGenderComparator());
    animals.addAll(candidates);
    for (Animal a : animals) {
        // ...
    }
    return numPairs;
}
```

在上面的代码中，animals 和 candidate 是函数的局部变量，被封闭在栈帧内部，不会逸出，被其它线程访问到，所以该方法是线程安全的。

## 线程局部变量

ThreadLocal 类能使线程中的某个值与保存值的对象关联起来，在单个线程内部共享这个变量，而其它线程无法访问。一个典型的示例是数据库连接会话，将连接会话存储为 ThreadLocal 对象，线程内部共享同一个连接会话，不同线程之间的连接会话互不影响。

```java
private static ThreadLocal<Connection> connectionHolder
        = new ThreadLocal<Connection>() {
            public Connection initialValue() {
                return DriverManager.getConnection(DB_URL);
            }
        };

public static Connection getConnection() {
    return connectionHolder.get();
}
```

## 避免可变状态

线程安全性是不可变对象的固有属性，对于不可变对象，所有线程看到状态必然是一致的。纯函数式编程语言中，没有变量，只有常量，状态不能被持有，只能通过函数参数来传递，所以是天然的线程安全。

Java 没有这样得天独厚的基因，不可变类型需要自己实现，具体的实现方式可以参考《Effective Java》 "最小化可变性"这一节，概括来讲需要遵循以下 5 条原则:

- 不要提供修改对象状态的方法
- 确保这个类不能被继承
- 把所有属性设置为 final
- 把所有的属性设置为 private
- 禁止访问类内部的可变域

Guava 库也提供了一组不可变类，比如 ImmutabelList、ImmutableSet 这些，我们应该在代码中尽可能地使用它们。
