![default](https://user-images.githubusercontent.com/5803001/45228854-de88b400-b2f6-11e8-9ab0-d393ed19f21f.png)

# 深入解析 PostgreSQL 系列之并发控制与事务机制

并发控制旨在针对数据库中对事务并行的场景，保证 ACID 中的一致性（Consistency）与隔离（Isolation）。数据库技术中主流的三种并发控制技术分别是： Multi-version Concurrency Control (MVCC), Strict Two-Phase Locking (S2PL), 以及 Optimistic Concurrency Control (OCC)，每种技术也都有很多的变种。在 MVCC 中，每次写操作都会在旧的版本之上创建新的版本，并且会保留旧的版本。当某个事务需要读取数据时，数据库系统会从所有的版本中选取出符合该事务隔离级别要求的版本。MVCC 的最大优势在于读并不会阻塞写，写也不会阻塞读；而像 S2PL 这样的系统，写事务会事先获取到排他锁，从而会阻塞读事务。

PostgreSQL 以及 Oracle 等 RDBMS 实际使用了所谓的 Snapshot Isolation（SI）这个 MVCC 技术的变种。Oracle 引入了额外的 Rollback Segments，当写入新的数据时，老版本的数据会被写入到 Rollback Segment 中，随后再被覆写到实际的数据块。PostgreSQL 则是使用了相对简单的实现方式，新的数据对象会被直接插入到关联的 Table Page 中；而在读取表数据的时候，PostgreSQL 会通过可见性检测规则（Visibility Check Rules）来选择合适的版本。

SI 能够避免 ANSI SQL-92 标准中定义的三个反常现象：脏读（Dirty Reads），不可重复读（Non-Repeatable Reads）以及幻读（Phantom Reads）；在 9.1 版本后引入的 Serializable Snapshot Isolation（SSI）则能够提供真正的顺序读写的能力。

| Isolation Level | Dirty Reads  | Non-repeatable Read | Phantom Read                                                                                                   | Serialization Anomaly |
| --------------- | ------------ | ------------------- | -------------------------------------------------------------------------------------------------------------- | --------------------- |
| READ COMMITTED  | Not possible | Possible            | Possible                                                                                                       | Possible              |
| REPEATABLE READ | Not possible | Not possible        | Not possible in PG; See [Section 5.7.2.](http://www.interdb.jp/pg/pgsql05.html#_5.7.2.) (Possible in ANSI SQL) | Possible              |
| SERIALIZABLE    | Not possible | Not possible        | Not possible                                                                                                   | Not possible          |

# Tuple 结构

## Transaction ID

当某个事务开启时，PostgreSQL 内置的 Transaction Manager 会为它分配唯一的 Transaction ID(txid)；txid 是 32 位无类型整型值，可以通过 `txid_current()` 函数来获取当前的 txid：

```sh
testdb=# BEGIN;
BEGIN
testdb=# SELECT txid_current();
 txid_current
--------------
          100
(1 row)
```

PostgreSQL 还保留了三个关键 txid 值作特殊标记：0 表示无效的 txid，1 表示启动时的 txid，仅在 Database Cluster 启动时使用；2 代表了被冻结的（Frozen）txid，用于在序列化事务时候使用。PostgreSQL 选择数值类型作为 txid，也是为了方便进行比较；对于  txid 值为 100 的事务而言，所有小于 100 的事务是发生在过去的，可见的；而所有大于 100 的事务，是发生在未来，即不可见的。

![image](https://user-images.githubusercontent.com/5803001/51909334-57ec8480-2407-11e9-965d-68ee0427ef03.png)

鉴于实际系统中的 txid 数目的需要可能会超过最大值，PostgreSQL 实际是将这些 txid 作为环来看待。

## HeapTupleHeaderData

Table Pages 中的 Heap Tuples 往往包含三个部分：HeapTupleHeaderData 结构，NULL bitmap 以及用户数据。

![image](https://user-images.githubusercontent.com/5803001/51910630-bebf6d00-240a-11e9-99aa-fb94a3cb9941.png)

其中 HeapTupleHeaderData 与事物处理强相关的属性有：

- (TransactionId)t_xmin: 存放插入该 Tuple 时的 txid
- (TransactionId)t_xmax: 存放删除或者更新该 Tuple 时的 txid，如果还没更新或者删除，那么置 0，表示无效
- (CommandId)t_cid: 存放 Command ID，即  创建该 Tuple 的命令在该事务内执行的所有 SQL 命令中的编号；譬如 `BEGIN; INSERT; INSERT; INSERT; COMMIT;` 这个事务，如果是首个 INSERT 命令创建的 Tuple，那么其 t_cid 值为 0，第二个就是 1
- (ItemPointerData)t_ctid: 当某个 Tuple 更新时，该值就指向新创建的 Tuple，否则指向自己

# Tuple 的插入、删除与更新

如上所述，Table Pages 中的 Tuples 呈如下布局：

![image](https://user-images.githubusercontent.com/5803001/51994715-5ba60700-24ec-11e9-89d3-37af876d4751.png)

## 插入

在执行插入操作时，PostgreSQL 会直接将某个新的 Tuple 插入到目标表的某个页中：

![image](https://user-images.githubusercontent.com/5803001/51994854-96a83a80-24ec-11e9-840e-e1bd2211d9ed.png)

假如某个 txid 为 99 的事务插入了新的 Tuple，那么该 Tuple 的头域会被设置为如下值：

- t_xmin 与创建该 Tuple 的事务的 txid 保持一致，即 99
- t_xmax 被设置为 0，因为其还未被删除或者更新
- t_cid 被设置为 0，因为该 Tuple 是由事务中的首个 Insert 命令创建的
- t_ctid 被设置为了 `(0, 1)`，即指向了自己

```sh
testdb=# CREATE EXTENSION pageinspect;
CREATE EXTENSION
testdb=# CREATE TABLE tbl (data text);
CREATE TABLE
testdb=# INSERT INTO tbl VALUES('A');
INSERT 0 1
testdb=# SELECT lp as tuple, t_xmin, t_xmax, t_field3 as t_cid, t_ctid
                FROM heap_page_items(get_raw_page('tbl', 0));
 tuple | t_xmin | t_xmax | t_cid | t_ctid
-------+--------+--------+-------+--------
     1 |     99 |      0 |     0 | (0,1)
```

## 删除

在删除操作中，目标 Tuple 会被先逻辑删除，即将 t_xmax 的值设置为当前删除该 Tuple 的事务的 txid 值。

![image](https://user-images.githubusercontent.com/5803001/51995164-25b55280-24ed-11e9-88dc-bcc0c52f5733.png)

当该事务被提交之后，PostgreSQL 会将该 Tuple 标记为 Dead Tuple，并随后在 VACUUM 处理过程中被彻底清除。

## 更新

## Free Space Map

# Commit Log

# Transaction Snapshot | 事务快照

# 可见性检测

# 空间整理
