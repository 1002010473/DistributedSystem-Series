
# 连接

在MySQL中，A left join B on condition 的执行过程如下：
1）以 table_A 为驱动表，检索 table_B
2）根据 on 条件过滤 table_B 的数据，构建 table_A 结果集，并且添加外部行。
3）对结果集执行 where 条件过滤。如果A中有一行匹配 where 子句但是B中没有一行匹配on条件，则生成另一个B行，其中所有列设置为NULL。
4）执行 group by 语句分组
5）执行 having 语句对分组结果筛选
6）执行 select 出结果集。
7）执行 distinct 对结果去重
8）执行 order by 语句
9）执行 limit 语句

MySQL会先进行连接查询，然后再使用where子句查询结果，再从结果执行order by。所以如果被驱动表数据过大，会造成检索行过多。可以利用子查询先查询出一个较小的结果集，然后再用连接驱动。

## Nested Loop Join

在MySQL中，只有一种 join 算法，就是 Nested Loop Join（嵌套循环连接），它没有其他很多数据库锁提供的 Hash Join，也没有Sort Merge Join。顾名思义，Nest Loop Join 实际上就是通过驱动表的结果集，作为循环基础数据，然后逐条通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。
如果还有第三个参与 Join ，则再通过前两个表的 Join 结果集作为循环基础数据，再一次通过循环查询条件到第三个表中查询数据，如此往复。

驱动表就是在嵌套循环和哈希连接中，用来最先获得数据，并以此表为依据，逐步获得其他表的数据，直至最终查询到所有符合条件的数据的第一个表。
驱动表不一定是表，也可以是一个数据集，即由某个表中满足条件的数据行组成的子集合。（同理被驱动表也不一定非得是表，也可以是一个数据集）

Simple Nested-Loop Join 从驱动表中取出R1匹配S表所有列，然后R2，R3,直到将R表中的所有数据匹配完，然后合并数据，可以看到这种算法要对S表进行RN次访问，虽然简单，但是相对来说开销还是太大了

![](https://upload-images.jianshu.io/upload_images/1053629-2d71b3dc6eb962f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700/format/webp)

Index Nested-Loop Join 索引嵌套联系由于非驱动表上有索引，所以比较的时候不再需要一条条记录进行比较，而可以通过索引来减少比较，从而加速查询。这也就是平时我们在做关联查询的时候必须要求关联字段有索引的一个主要原因。
这种算法在链接查询的时候，驱动表会根据关联字段的索引进行查找，当在索引上找到了符合的值，再回表进行查询，也就是只有当匹配到索引以后才会进行回表。至于驱动表的选择，MySQL优化器一般情况下是会选择记录数少的作为驱动表，但是当SQL特别复杂的时候不排除会出现错误选择。
在索引嵌套链接的方式下，如果非驱动表的关联键是主键的话，这样来说性能就会非常的高，如果不是主键的话，关联起来如果返回的行数很多的话，效率就会特别的低，因为要多次的回表操作。先关联索引，然后根据二级索引的主键ID进行回表的操作。这样来说的话性能相对就会很差。

![](https://images2015.cnblogs.com/blog/695151/201707/695151-20170705185523503-834605858.png)

在有索引的情况下，MySQL会尝试去使用Index Nested-Loop Join算法，在有些情况下，可能Join的列就是没有索引，那么这时MySQL的选择绝对不会是最先介绍的Simple Nested-Loop Join算法，而是会优先使用Block Nested-Loop Join的算法。
Block Nested-Loop Join对比Simple Nested-Loop Join多了一个中间处理的过程，也就是join buffer，使用join buffer将驱动表的查询JOIN相关列都给缓冲到了JOIN BUFFER当中，然后批量与非驱动表进行比较，这也来实现的话，可以将多次比较合并到一次，降低了非驱动表的访问频率。也就是只需要访问一次S表。这样来说的话，就不会出现多次访问非驱动表的情况了，也只有这种情况下才会访问join buffer。
在MySQL当中，我们可以通过参数join_buffer_size来设置join buffer的值，然后再进行操作。默认情况下join_buffer_size=256K，在查找的时候MySQL会将所有的需要的列缓存到join buffer当中，包括select的列，而不是仅仅只缓存关联列。在一个有N个JOIN关联的SQL当中会在执行时候分配N-1个join buffer。

![](https://upload-images.jianshu.io/upload_images/1053629-0bcdb1b15dbf8e7f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/710/format/webp)

# 索引优化
## 最左前缀匹配原则
还拿前面的employees表举例，比如我们建立一个`(birth_date, first_name, last_name )` 的组合索引。
```
mysql> alter table employees add index bd_fn_ln (birth_date, first_name, last_name);
```
下面的查询是用到索引的：
```
mysql> select * from employees where birth_date = '1954-05-01' and first_name = 'Chirstian' and last_name = 'Koblick';

mysql> select * from employees where birth_date = '1954-05-01' and first_name = 'Chirstian';

mysql> select * from employees where birth_date = '1954-05-01' and last_name = 'Koblick';
```
下面是这三个查询explain结果。
```
mysql> explain select * from employees where birth_date = '1954-05-01' and first_name = 'Chirstian' and last_name = 'Koblick';

+----+-------------+-----------+------+---------------+----------+---------+-------------------+------+-----------------------+

| id | select_type | table     | type | possible_keys | key      | key_len | ref               | rows | Extra                 |

+----+-------------+-----------+------+---------------+----------+---------+-------------------+------+-----------------------+

|  1 | SIMPLE      | employees | ref  | bd_fn_ln      | bd_fn_ln | 97      | const,const,const |    1 | Using index condition |

+----+-------------+-----------+------+---------------+----------+---------+-------------------+------+-----------------------+

1 row in set (0.00 sec)

mysql> explain select * from employees where birth_date = '1954-05-01' and first_name = 'Chirstian' ;

+----+-------------+-----------+------+---------------+----------+---------+-------------+------+-----------------------+

| id | select_type | table     | type | possible_keys | key      | key_len | ref         | rows | Extra                 |

+----+-------------+-----------+------+---------------+----------+---------+-------------+------+-----------------------+

|  1 | SIMPLE      | employees | ref  | bd_fn_ln      | bd_fn_ln | 47      | const,const |    1 | Using index condition |

+----+-------------+-----------+------+---------------+----------+---------+-------------+------+-----------------------+

1 row in set (0.01 sec)

mysql> explain select * from employees where birth_date = '1954-05-01' and last_name = 'Koblick';

+----+-------------+-----------+------+---------------+----------+---------+-------+------+-----------------------+

| id | select_type | table     | type | possible_keys | key      | key_len | ref   | rows | Extra                 |

+----+-------------+-----------+------+---------------+----------+---------+-------+------+-----------------------+

|  1 | SIMPLE      | employees | ref  | bd_fn_ln      | bd_fn_ln | 3       | const |   60 | Using index condition |

+----+-------------+-----------+------+---------------+----------+---------+-------+------+-----------------------+

1 row in set (0.00 sec)
```
虽然结果都是一条，不过前两个查询都用到了联合索引。最后一个只用到了`birth_date`这一个索引，所以会在`birth_date = 1954-05-01` 的60结果中遍历`last_name`来找到等于`Koblick`的结果。还有, 如果where中都是精确匹配(使用'='号)，那它们的顺序不会影响索引的使用。

而下面这个查询因为没用到组合索引的最左列，所以不会用到索引而是遍历了所有的数据，这就是最左前缀匹配：
```
mysql> select * from employees where first_name = 'Chirstian' and last_name = 'Koblick';

+--------+------------+------------+-----------+--------+------------+

| emp_no | birth_date | first_name | last_name | gender | hire_date  |

+--------+------------+------------+-----------+--------+------------+

|  10004 | 1954-05-01 | Chirstian  | Koblick   | M      | 1986-12-01 |

+--------+------------+------------+-----------+--------+------------+

1 row in set (0.18 sec)

mysql> explain select * from employees where first_name = 'Chirstian' and last_name = 'Koblick';

+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+

| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |

+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+

|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 299468 | Using where |

+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+

1 row in set (0.00 sec)
```
## 选择区分度高的列作为索引
区分度：count(distinct col)/count(*)。
区分度是一个介于0和1之间的小数，越接近1区分度越高，越适合做索引。
原因很容易理解，比如一个辞典中全是以a和b开头的单词，那么按照首字母简历一个目录(索引)，那么目录上一共就两条，每条的范围对应差不多半本辞典，那这个目录(索引)毫无用处。相反，一个班级的学生信息以学号做索引，那么区分度为1，只要找到学号就能直接找到相对应的学生信息，这个索引就非常有效。

## 不要在比较运算符左侧使用函数或进行计算
在sql语句的比较运算符左侧使用函数或进行计算会使索引失效。
```

mysql> explain select * from employees where emp_no + 1 = 10005;
+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+
| id | select_type | table     | type | possible_keys | key  | key_len | ref  | rows   | Extra       |
+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+
|  1 | SIMPLE      | employees | ALL  | NULL          | NULL | NULL    | NULL | 299468 | Using where |
+----+-------------+-----------+------+---------------+------+---------+------+--------+-------------+
1 row in set (0.11 sec)

mysql> explain select * from employees where emp_no = 10005-1;
+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+
| id | select_type | table     | type  | possible_keys | key     | key_len | ref   | rows | Extra |
+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+
|  1 | SIMPLE      | employees | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  |
+----+-------------+-----------+-------+---------------+---------+---------+-------+------+-------+
1 row in set (0.00 sec)
```

