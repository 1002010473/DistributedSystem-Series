# 索引构建

# 索引基础

## 单词 - 文档矩阵

单词-文档矩阵是表达两者之间所具有的一种包含关系的概念模型，如下图所示，每列代表一个文档，每行代表一个单词，打对钩的位置代表包含关系。

![](http://images2015.cnblogs.com/blog/437647/201605/437647-20160505171935451-98434976.png)

从纵向看，可以得知每列代表文档包含了哪些单词；从横向看，每行代表了哪些文档包含了某个单词。搜索引擎的索引其实就是实现单词-文档矩阵的具体数据结 构。可以有不同的方式来实现上述概念模型，比如倒排索引、签名文件、后缀树等方式。但实验数据表明，倒排索引是单词到文档映射关系的最佳实现方式。

## 倒排索引

文档(Document )：以文本形式存在的存储对象。如：网页、Word 、 PDF、XML 等不同格式的文件。文档集合(Document Collection )：若干文档构成的集合。如：大量的网页。文档编号(Document ID )：搜索引擎内部，唯一标识文档的唯一编号。单词编号(Word ID )：搜索引擎内部，唯一标识单词的唯一编号。倒排索引(Inverted Index )：实现单词 -- 文档矩阵的一种具体存储形式。倒排索引主要有单词词典和倒排文件组成。单词词典(Lexicon )：文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息及指向倒排列表的指针。倒排列表(PostingList )：出现了某个单词的所有文档的文档列表及单词在该文档中出现的位置信息。列表中每条记录称为一个倒排项(Posting )。倒排文件(Inverted File )：保存所有单词的倒排列表的文件，倒排文件是存储倒排索引的物理文件。

![](http://images2015.cnblogs.com/blog/437647/201605/437647-20160505174530763-1021419336.png)

## 倒排索引实例

下面举一个实例，这样对倒排索引有一个更直观的感受。

假设文档集合包含 5 个文档，每个文档内容如下图所示：

![img](http://images2015.cnblogs.com/blog/437647/201605/437647-20160505181011857-687389334.png)

建立的倒排索引如下图：

![img](http://images2015.cnblogs.com/blog/437647/201605/437647-20160505181733638-78678242.png)

单词 ID：记录每个单词的单词编号；

单词：对应的单词；

文档频率：代表再文档集合中有多少个文档包含某个单词

倒排列表：包含单词 ID 及其他必要信息

TF：单词在某个文档中出现的次数

POS：单词在文档中出现的位置

以单词 “ 加盟 ” 为例，其单词编号为 8，文档频率为 3，代表整个文档集合中有三个文档包含这个单词，对应的倒排列表为 {(2;1;<4>),(3;1;<7>),(5;1;<5>)}，含义是在文档 2，3 ， 5 出现过这个单词，在每个文档的出现过 1 次，单词 “ 加盟 ” 在第一个文档的 POS 是 4，即文档的第四个单词是 “ 加盟 ”，其他的类似。

这个倒排索引已经是一个非常完备的索引系统，实际搜索系统的索引结构基本如此。

## 单词词典

单词词典用来维护文档集合中出现过的所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在查询时到单词词典里查询，就能获得相应的倒排列表，并以此作为后序排序的基础。常用数据结构：哈希加链表和树形词典结构。

### 哈希加链表

下图是哈希加链表词典结构的示意图。主体是哈希表，每个哈希表项保存一个指针，指针指向冲突连表，相同哈希值的单词形成链表结构。

![img](http://images2015.cnblogs.com/blog/437647/201605/437647-20160506105900201-30795472.png)

构建过程：对文档进行分词；对于做好的分词，利用哈希函数获取哈希值；根据哈希值对应的哈希表项找到对应的冲突链表；如果冲突链表已经存在该单词 　　不处理否则 　　加入冲突连表

### 树形结构

使用 B 树或者 B+ 树的结构。与哈希表不同的是，需要字典项能按照大小排序，即使用数字或字符序。树形结构中，使用层级查找，中间节点保存一定顺序范围的词典项目存储在哪个子树中，最底层的叶子节点存储单词的地址信息。

## 倒排列表

倒排列表用来记录哪些文档包含了某个单词。倒排列表由倒排索引项组成，每个倒排索引项由文档 ID，单词出现次数 TD 以及单词在文档中哪些位置出现过等信息。包含某单词的一些列倒排索引项形成了某个单词对应的倒排列表。下图是倒排列表示意图: ![](http://images2015.cnblogs.com/blog/437647/201605/437647-20160506111013341-2082794303.png)

# 索引建立

## 2-Pass In-Memory Inversion: 两遍文档遍历法

此方法在内存里完成索引的创建过程。要求内存要足够大。第一遍收集一些全局的统计信息。包括文档集合包含的文档个数 N，文档集合内所包含的不同单词个数 M，每个单词在多少个文档中出现过的信息 DF。将所有单词对应的 DF 值全部相加，就可以知道建立最终索引所需的内存大小是多少。获取信息后，根据统计信息分配内存等资源，同事建立好单词相对应倒排列表在内存中的位置信息。

第二遍逐个单词建立倒排列表信息。获得包含某个单词的每个文档的文档 ID，以及这个单词在文档中的出现次数 TF，然后不断填充第一遍扫描时所分配的内存。当第二遍扫描结束的时候，分配的内存正好被填充满，每个单词用指针所指向的内存区域 “ 片段 ”，其起始位置和终止位置之间的数据就是这个单词对应的倒排列表。

## Sort-Based Inversion: 排序法

在建立索引过程中，始终在内存中分配固定大小的空间，用来存放词典信息和索引的中间结果，当分配的空间被消耗光的时候，把中间结果写入磁盘，清空内存里中间结果所占空间，以用做下一轮存放索引中间结果的存储区。参考下图: ![](http://images2015.cnblogs.com/blog/437647/201605/437647-20160506114358888-1226132243.png) 上图是排序法建立索引中间结果的示意图。建立过程：读入文档后，对文档进行编号，赋予唯一的文档 ID，并对文档内容解析；将单词映射为单词 ID；建立(单词 ID、文档 ID、单词频率)三元组；将三元组追加进中间结果存储区末尾；然后依次序处理下一个文档；当分配的内存定额被占满时，则对中间结果进行排序(根据单词 ID-> 文档 ID 的排序原则)；将排好序的三元组写入磁盘文件中。注：在排序法建立索引的过程中，词典是一直存储在内存中的，由于分配内存是固定大小，渐渐地词典占用内存越来越大，那么，越往后，可用来存储三元组的空间越来越少。建立好索引后，需要合并。合并时，系统为每个中间结果文件在内存中开辟一个数据缓冲区，用来存放文件的部分数据。将不同缓冲区中包含的同一 个单词 ID 的三元组进行合并，如果某个单词 ID 的所有三元组全部合并完成，说明这个单词的倒排列表已经构建完成，则将其写入最终索引中，同事将各个缓冲区 中对应这个单词 ID 的三元组内容清空。缓冲区继续从中间结果文件读取后续的三元组进行下一轮合并。当所有中间结果文件都依次被读入缓冲区，并合并完成后， 形成最终的索引文件。

## Merge-Based Inversion: 归并法

归并法与排序法类似，不同的是，每次将内存中数据写入磁盘时，包括词典在内的所有中间结果都被写入磁盘，这样内存所有内容都可以被清空，后续建立索引可以使用全部的定额内存。归并法的示意图如下所示: ![](http://images2015.cnblogs.com/blog/437647/201605/437647-20160506120407310-1507307319.png) 与排序法的差异: 1 、排序法在内存中存放的是词典信息和三元组数据，词典和三元组数据并没有直接的联系，词典只是为了将单词映射为单词 ID。归并法则是在内存中建立一个完整的内存索引结构，是最终文章索引的一部分。 2 、在将中间结果写入磁盘临时文件时，归并法将这个内存的倒排索引写入临时文件，随后彻底清空所占内存。而排序法只是将三元组数据排序后写入磁盘临时文件，词典作为一个映射表一直存储在内存中。 3 、合并时，排序法是对同一单词的三元组依次进行合并；归并法的临时文件则是每个单词对应的部分倒排列表，所以在合并时针对每个单词的倒排列表进行合并，形成这个单词的最终倒排列表。

# 分布式索引(Parallel Indexing )

当搜索引擎需要处理的文档集合太多的时候，就需要考虑分布式解决方案。每台机器维护整个索引的一部分，有多台机器协作来完成索引的建立和对查询的响应。

## 按文档划分(Document Paritioning )

将整个文档集合切割成若干个子集合，而每台机器负责对某个文档子集合建立索引，并响应查询请求。按文档划分示意图如下：

![img](http://images2015.cnblogs.com/blog/437647/201605/437647-20160506182559201-621869062.png) 工作原理：查询分发服务器接收到用户查询请求后，将查询广播给所有索引服务器。每个索引服务器负责部分文档子集合的索引维护和查询响应。当索引服务器接收到用户查询后，计算相关文档，并将得分最高的 K 个文档送返查询分发服务器。查询分发服务器综合各个索引服务器的搜索结果后，合并搜索结果，将得分最高的 m 个文档作为最终搜索结果返回给用户。

## 按单词划分(Term Paritioning )

每个索引服务器负责词典中部分单词的倒排列表的建立和维护。按单词划分示意图如下：

![img](http://images2015.cnblogs.com/blog/437647/201605/437647-20160506182657763-1576592839.png)

工作原理：一次一个单词。假设查询包含 A、B 、 C 三个单词，查询服务器接收到查询后，将查询转发到包含单词 A 倒排列表的索引服务器节点 1，索引服务器节点 1 提取 A 的倒排列表，并累计计算搜索结果的中间的分，然后将查询和中间结果传递给包含单词 B 倒排列表的索引服务器节点，索引服务器节点 2 也是类似处理，并继续到索引服务器节点 3。然后将最终结果返回给查询分发服务器，查询分发服务器计算得分最高的 K 个文档作为搜索结果输出。

### **两种方案比较**

按文档比较常用，按单词划分只在特殊应用场合才使用。按单词划分的不足: **可扩展性** 搜索引擎处理的文档是经常变动的。如果按文档来对索引划分，只需要增加索引服务器，操作起来很方便。但如果是按单词进行索引划分，则对几乎所有的索引服务器都有直接影响，因为新增文档可能包含所有词典单词，即需要对每个单词的倒排列表进行更新，实现起来相对复杂。

**负载均衡** 常用单词的倒排列表非常庞大，可能会达到几十 M 大小。如果按文档划分，这种单词的倒排列表会比较均匀地分布在不同的索引服务器上，而按单词进行索引划分，某个常见单词的倒排列表全部内容都由一台索引服务器维护。如果该单词同时是一个流行词汇，那么该服务器会成为负载过大的性能瓶颈。

**容错性** 假设某台服务器出现故障。如果按文档进行划分，那么只影响部分文档子集合，其他索引服务器仍然能响应。但如果按单词进行划分，若索引服务器发生故障，则某些单词的倒排列表无法访问，用户查询这些单词的时候，会发现没有搜索结果，直接影响用户体验。

**对查询处理方式的支持** 按单词进行索引一次只能查询一个单词，而按文档划分的不受此限制。
