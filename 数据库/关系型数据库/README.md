# 关系型数据库

# ACID

事务提供一种全做，或不做(All or Nothing)的机制，即将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。数据库事务具有 ACID 属性，即原子性(Atomic)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)，在[分布式事务 https://url.wx-coder.cn/7p8Xx ](https://url.wx-coder.cn/7p8Xx)中我们也会讨论分布式系统中应该如何实现事务机制。

ACID 包含了描述事务操作的整体性的原子性，描述事务操作下数据的正确性的一致性，描述事务并发操作下数据的正确性的隔离性，描述事务对数据修改的可靠性的持久性。针对数据库的一系列操作提供了一种从失败状态恢复到正常状态的方法，使数据库在异常状态下也能够保持数据的一致性，且面对并发访问时，数据库能够提供一种隔离方法，避免彼此间的操作互相干扰。

## Atomicity | 原子性

整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

例如：银行转账，从 A 账户转 100 元至 B 账户，分为两个步骤：从 A 账户取 100 元；存入 100 元至 B 账户。这两步要么一起完成，要么一起不完成。

## Consistency | 一致性

在事务开始之前和事务结束以后，数据库数据的一致性约束没有被破坏。 例如：现有完整性约束 A+B=100，如果一个事务改变了 A，那么必须得改变 B，使得事务结束后依然满足 A+B=100，否则事务失败。

## Isolation | 隔离性

数据库允许多个并发事务同时对数据进行读写和修改的能力，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。

隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。 例如：现有有个交易是从 A 账户转 100 元至 B 账户，在这个交易事务还未完成的情况下，如果此时 B 查询自己的账户，是看不到新增加的 100 元的。

# 隔离级别

SQL 标准定义了 4 类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

- **Read Uncommitted (未提交读)：** 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。**读取未提交的数据，也被称之为脏读(Dirty Read )。**

* **Read Committed (提交读)：**这是大多数数据库系统的默认隔离级别(但不是[MySQL](http://lib.csdn.net/base/14)默认的)。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的**不可重复读(Nonrepeatable Read )**，因为同一事务的其他实例在该实例处理其间可能会有新的 commit，所以同一查询可能返回不同结果。

- **Repeatable Read (可重复读)：**这是 MySQL 的默认事务隔离级别，它确保在一个事务内的相同查询条件的多次查询会看到同样的数据行，都是事务开始时的数据快照。不过理论上，这会导致另一个棘手的问题：**幻读 (Phantom Read )**，怎么理解幻读？简单说，就是当某个事务在读取某个范围内的记录时， 另外的一个事务又在该范围内插入新的记录。在之前的事务在读取该范围的记录时，就会产生幻行。( InnoDB 通过间隙锁(next-key locking )策略防止幻读的出现)

* **Serializable (可串行化)：**这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。

| 离级别                      | 脏读(Dirty Read ) | 不可重复读(NonRepeatable Read ) | 幻读(Phantom Read ) |
| --------------------------- | ----------------- | ------------------------------- | ------------------- |
| 未提交读(Read uncommitted ) | 可能              | 可能                            | 可能                |
| 提交读(Read committed )     | 不可能            | 可能                            | 可能                |
| 可重复读(Repeatable read )  | 不可能            | 不可能                          | 可能                |
| 可串行化(Serializable )     | 不可能            | 不可能                          | 不可能              |

### Read uncommitted 读未提交

公司发工资了，领导把 5000 元打到 singo 的账号上，但是该事务并未提交，而 singo 正好去查看账户，发现工资已经到账，是 5000 元整，非常高兴。可是不幸的是，领导发现发给 singo 的工资金额不对，是 2000 元，于是迅速回滚了事务，修改金额后，将事务提交，最后 singo 实际的工资只有 2000 元，singo 空欢喜一场。

![img](http://dl.iteye.com/upload/attachment/556524/f244ae46-c8f4-3bc1-906e-d1d9c1af3516.gif)

出现上述情况，即我们所说的脏读，两个并发的事务，“ 事务 A：领导给 singo 发工资 ”、“ 事务 B：singo 查询工资账户 ”，事务 B 读取了事务 A 尚未提交的数据。

当隔离级别设置为 Read uncommitted 时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。

### Read committed 读提交

singo 拿着工资卡去消费，系统读取到卡里确实有 2000 元，而此时她的老婆也正好在网上转账，把 singo 工资卡的 2000 元转到另一账户，并在 singo 之前提交了事务，当 singo 扣款时，系统检查到 singo 的工资卡已经没有钱，扣款失败，singo 十分纳闷，明明卡里有钱，为何 ......

出现上述情况，即我们所说的不可重复读，两个并发的事务，“ 事务 A：singo 消费 ”、“ 事务 B：singo 的老婆网上转账 ”，事务 A 事先读取了数据，事务 B 紧接了更新了数据，并提交了事务，而事务 A 再次读取该数据时，数据已经发生了改变。

当隔离级别设置为 Read committed 时，避免了脏读，但是可能会造成不可重复读。

大多数数据库的默认级别就是 Read committed，比如 Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。

### Repeatable read 重复读

不可重复读是指事务 T1 读取数据后，事务 T2 执行更新操作，使 T1 无法再现前一次读取结果。具体地讲，不可重复读包括三种情况：

事务 T1 读取某一数据后，事务 T2 对其做了修改，当事务 1 再次读该数据时，得到与前一次不同的值。例如，T1 读取 B=100 进行运算，T2 读取同一数据 B，对其进行修改后将 B=200 写回数据库。T1 为了对读取值校对重读 B，B 已为 200，与第一次读取值不一致。

事务 T1 按一定条件从数据库中读取了某些数据记录后，事务 T2 删除了其中部分记录，当 T1 再次按相同条件读取数据时，发现某些记录神密地消失了。 事务 T1 按一定条件从数据库中读取某些数据记录后，事务 T2 插入了一些记录，当 T1 再次按相同条件读取数据时，发现多了一些记录。(这也叫做幻影读)

当隔离级别设置为 Repeatable read 时，可以避免不可重复读。当 singo 拿着工资卡去消费时，一旦系统开始读取工资卡信息(即事务开始)， singo 的老婆就不可能对该记录进行修改，也就是 singo 的老婆不能在此时转账。

虽然 Repeatable read 避免了不可重复读，但还有可能出现幻读。

singo 的老婆工作在银行部门，她时常通过银行内部系统查看 singo 的信用卡消费记录。有一天，她正在查询到 singo 当月信用卡的总消费金额(select sum(amount) from transaction where month = 本月)为 80 元，而 singo 此时正好在外面胡吃海塞后在收银台买单，消费 1000 元，即新增了一条 1000 元的消费记录(insert transaction ... )，并提交了事务，随后 singo 的老婆将 singo 当月信用卡消费的明细打印到 A4 纸上，却发现消费总额为 1080 元，singo 的老婆很诧异，以为出现了幻觉，幻读就这样产生了。

注：[MySQL](http://lib.csdn.net/base/14)行锁的默认隔离级别就是 Repeatable read。

### Serializable 序列化

Serializable 是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。
