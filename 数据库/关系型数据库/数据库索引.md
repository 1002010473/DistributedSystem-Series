![default](https://user-images.githubusercontent.com/5803001/45228854-de88b400-b2f6-11e8-9ab0-d393ed19f21f.png)

# 数据库索引

本文承接[数据结构与算法--索引 https://url.wx-coder.cn/O07eI](https://url.wx-coder.cn/O07eI) 一节，介绍文件索引在数据库系统中的实际应用。

索引（Index）是帮助数据库系统高效获取数据的数据结构，数据库索引本质上是以增加额外的写操作与用于维护索引数据结构的存储空间为代价的用于提升数据库中数据检索效率的数据结构。索引可以帮助我们快速地定位到数据而不需要每次搜索的时候都遍历数据库中的每一行。

当然，索引不是建立的越多、越长越好，因为索引除了占用空间之外，对后续数据库的增加、删除、修改都有额外的操作来更新索引。小表使用全表扫描更快，中大表才使用索引。超级大表索引基本无效。

对索引列和字符串前缀长度，都参考选择性(Selectivity)这个指标来确定：选择性定义为不重复的索引值和数据总记录条数的比值，其选择性越高，那么索引的查询效率也越高，譬如对于性别这种参数，建立索引根本没有意义。

# 索引类型

索引从实现上说，分成 2 种：聚集索引和辅助索引（也叫二级索引或者非聚集索引）；从功能上说，分为 6 种：普通索引，唯一索引，主键索引，复合索引，外键索引，全文索引。

MySQL 自带的全文索引只能用于 InnoDB、MyISAM ，并且只能对英文进行全文检索，一般使用全文索引引擎（ES，Solr）。对于全文索引的相关算法可以参考

InnoDB 是聚集索引，因为它的 B+ 树的叶结点包含了完整的数据记录。而 MyISAM 方式 B+ 树的叶结点只是存储了数据的地址，故称为非聚集索引。在 InnoDB 中，又有聚簇索引和普通索引之分，聚簇索引根据主键来构建，叶子节点存放的是该主键对应的这一行记录，而普通索引根据申明这个索引时候的列来构建，叶子节点存放的是这一行记录对应的主键的值，而普通索引中还有唯一索引和联合索引两个特例，唯一索引在插入和修改的时候会校验该索引对应的列的值是否已经存在，而联合索引将两个列的值按照申明时候的顺序进行拼接后在构建索引。

![](https://tva1.sinaimg.cn/large/007rAy9hgy1g3ceus147fj30se0duwf7.jpg)

数据是以行为单位存储在聚簇索引里的，根据主键查询可以直接利用聚簇索引定位到所在记录，根据普通索引查询需要先在普通索引上找到对应的主键的值，然后根据主键值去聚簇索引上查找记录，俗称回表。

数据行并不是存储引擎管理的最小存储单位，索引只能够帮助我们定位到某个数据页，每一次磁盘读写的最小单位为也是数据页，而一个数据页内存储了多个数据行，我们需要了解数据页的内部结构才能知道存储引擎怎么定位到某一个数据行。

如果想对于 Innodb 引擎对于索引的底层存储方式，建议阅读

# 主键

InnoDB 通过主键聚簇数据，如果没有定义主键且没有定义聚集索引， MySql 会选择一个唯一的非空索引代替，如果没有这样的索引，会隐式定义个 6 字节的主键作为聚簇索引，用户不能查看或访问。

在 InnoDB 存储引擎表中，每张表都有个主键，如果在创建表时没有显式地定义主键（Primary Key），则 InnoDB 存储引擎会按如下方式选择或创建主键：

- 首先表中是否有非空的唯一索引（Unique NOT NULL），如果有，则该列即为主键。

- 不符合上述条件，InnoDB 存储引擎自动创建一个 6 个字节大小的指针。

对于字符串类型，可以指定索引前缀长度(且对于 BLOB/TEXT 前缀长度参数是必须的)，在 InnoDB 表中其前缀长度最长是 767 bytes，且参数 M 是用 bytes 计量的。所以太长的字符串，建立 BTree 索引浪费比较大，这时候用手动模拟 HASH 索引是个方法，不过这种方式对字符串无法灵活的使用前缀方式查询(例如 LIKE 这类的操作)。

主键必须唯一，与索引不同的是不能有 Null，而且一个表只能有一个主键。有很多人认为主键是唯一索引的一种，其实是不准确的。主键也可以是组合索引，只要组合的每条结果是唯一的。这在某些场景非常实用，比如一个多对多关系中的枢纽表就非常适合使用复合主键。在 InnoDB 内部，表数据是优化主键快速查询而排列分布的，其查找速度是最快的(相当于聚簇索引：该索引中键值的逻辑顺序决定了表中相应行的物理顺序)。即使表中没有适合做主键的列，也推荐采用一个自动增长的整数主键(代理键)，那么这个表在增加数据的时候是顺序存放的，而且后续在别的表参考该外键查询的时候也会得到优化。

MySQL官方有明确的建议主键要尽量越短越好[4]，36个字符长度的UUID不符合要求。如果作为数据库主键，在InnoDB引擎下，UUID的无序性可能会引起数据位置频繁变动，严重影响性能。

普通索引上存储的值是主键的值，如果主键是一个很长的字符串并且建了很多普通索引，将造成普通索引占有很大的物理空间，这也是为什么建议使用 自增ID 来替代订单号作为主键，另一个原因是 自增ID 在插入的时候可以保证相邻的两条记录可能在同一个数据块，而订单号的连续性在设计上可能没有自增ID好，导致连续插入可能在多个数据块，增加了磁盘读写次数。

常见的主键的形式有自增 ID 与 UUID 等，自增的优势在于：

- 唯一性：自增 ID 很容易会被暴力破解，数据迁移的时候，特别是发生表格合并这种操作的时候，会不可避免地存在冲突。UUID 则能够保证唯一性，彻底避免冲突。
- 键长度：自增字段的长度较 UUID 小很多，这会对检索的性能有较大影响。Innodb 引擎进行数据检索时，也是先根据索引找到主键，然后根据主键找到记录；这样在主键长度短的情况下，会有较好的读性能。
- 并发性：自增 ID 并且高并发的情况下，竞争自增锁会降低数据库的吞吐能力。UUID 则能够在应用层生成 UUID，提高数据库的吞吐能力。
- 数据库索引：InnoDB 中表数据是按照主键顺序存放的，在写入数据时候如果发生了随机 IO，那么就会频繁地移动磁盘块。当数据量大的时候，写的短板将非常明显。自增 ID 中新增的数据可以默认按序排列，对于性能有很大的提升；UUID 则主键之间没有顺序规律。

我们建议的方式是使用 Snowflake 算法，在[分布式 ID https://url.wx-coder.cn/tQ5eH](https://url.wx-coder.cn/tQ5eH)部分我们也有详细讨论。

# 普通索引与唯一索引

主键就是唯一索引，但是唯一索引不一定是主键，唯一索引可以为空，但是空值只能有一个，主键不能为空。

UNIQUE 索引要求索引是唯一的。对于单列索引，要求该列所有数据都不相同，但允许有 NULL 值；对于多列的组合索引，要求这些列的组合是唯一的。UNIQUE 索引其本身既可以作为索引，实际中也可以用以产生数据约束，防止增加或者修改后产生相同数据，从而保证数据的完整性。

# 联合索引

如果我们查询一整行记录的话，一定要去聚簇索引上查找，而如果我们只需要根据普通索引查询主键的值，由于这些值在普通索引上已经存在，所以并不需要回表，这个称为索引覆盖，在一定程度上可以提高查询效率，由于联合索引上通过多个列构建索引，有时候我们可以将需要频繁查询的字段加到联合索引里面，例如如果经常需要根据 name 查找 age 我们可以建一个 name 和 age 的联合索引。

查询的时候如果在索引上用了函数，将导致无法用到根据之前列上的值构建的索引，索引遵循最左匹配原则，所以如果需要查询某个列的值中间是否包含某个字符串，将无法利用索引，如果有这种需求可以利用全文索引，而如果查询是否以某个字符串开头就可以，联合索引根据第一个列查询可以用到索引，仅仅根据第二个列将无法用到索引，查询的时候用 IN 的效率高于 NOT = 。另外建议将索引的列设置为非空，这个和 NULL 字段的存储有关

在建立多列索引的时候，必须按照从左到右的顺序使用全部或部分的索引列，才能充分的使用组合索引，比如：(col1, col2, col3)使用(col1)、(col1, col2)、(col1, col2, col3)有效。在查询语句中会一直向右匹配直到遇到范围查询(>,<,BETWEEN,LIKE)就停止匹配，其后的索引列将不会使用索引来优化查找了。

普通索引，对数据没有约束要求，多行记录可以包含相同值。无论对于字符串索引，还是多列组合索引，都以及在查询语句中，都有个最左前缀的原则：

B-Tree 索引可以很好地用于单行、范围或者前缀扫描，他们只有在查找使用了索引的最左前缀（Leftmost Prefix）的时候才有用。不过 B-Tree 索引存在一些限制：

- 如果查找不从索引列的最左边开始，索引就无法使用；同样，不能查找字符串结尾；
- 不能跳过索引中的列；
- 不能使用任何在第一个范围条件右边的列作为条件；

因此 B-Tree 的列顺序非常重要，上述使用规则都和列顺序有关。对于实际的应用，一般要根据具体的需求，创建不同列和不同列顺序的索引。假设有索引 Index(A,B,C):

```sh
# 使用索引
A>5 AND A<10 - 最左前缀匹配
A=5 AND B>6 - 最左前缀匹配
A=5 AND B=6 AND C=7 - 全列匹配
A=5 AND B IN (2,3) AND C>5 - 最左前缀匹配，填坑

# 不能使用索引
B>5 - 没有包含最左前缀
B=6 AND C=7 - 没有包含最左前缀

# 使用部分索引
A>5 AND B=2 - 使用索引 A 列
A=5 AND B>6 AND C=2 - 使用索引的 A 和 B 列
```

使用索引对结果进行排序，需要索引的顺序和 ORDER BY 子句中的顺序一致，并且所有列的升降序一致(ASC/DESC)。如果查询连接了多个表，只有在 ORDER BY 的列引用的是第一个表才可以(需要按序 JOIN)。

```sh
# 使用索引排序
ORDER BY A - 最左前缀匹配
WHERE A=5 ORDER BY B,C - 最左前缀匹配
WHERE A=5 ORDER BY B DESC - 最左前缀匹配
WHERE A>5 ORDER BY A,B - 最左前缀匹配

# 不能使用索引排序
WHERE A=5 ORDER BY B DESC,C ASC - 升降序不一致
WHERE A=5 ORDER BY B,D - D 不在索引中
WHERE A=5 ORDER BY C - 没有包含最左前缀
WHERE A>5 ORDER BY B,C - 第一列是范围条件，无法使用 BC 排序
WHERE A=5 AND B IN(1, 2) ORDER BY C - B 也是范围条件，无法用 C 排序
```

# 链接

- 几篇关于数据库索引的文章 https://ruby-china.org/topics/26352 https://www.cnblogs.com/kenshinobiy/p/4360371.html https://www.cnblogs.com/kenshinobiy/p/4360371.html

- https://www.atatech.org/articles/130831?flag_data_from=mail_daily_group&uid=430792

- https://www.jianshu.com/p/6446c0118427

- https://zhuanlan.zhihu.com/p/23624390

- https://mp.weixin.qq.com/s/Wc6Gw6S5xMy2DhTCrogxVQ
