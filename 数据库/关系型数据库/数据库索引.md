![default](https://user-images.githubusercontent.com/5803001/45228854-de88b400-b2f6-11e8-9ab0-d393ed19f21f.png)

# 数据库索引

索引（Index）是帮助数据库系统高效获取数据的数据结构，数据库索引本质上是以增加额外的写操作与用于维护索引数据结构的存储空间为代价的用于提升数据库中数据检索效率的数据结构。索引可以帮助我们快速地定位到数据而不需要每次搜索的时候都遍历数据库中的每一行。

本文承接[索引算法 https://url.wx-coder.cn/O07eI](https://url.wx-coder.cn/O07eI) 一节，介绍文件索引在数据库系统中的实际应用。

InnoDB 是聚集索引，因为它的 B+ 树的叶结点包含了完整的数据记录。而 MyISAM 方式 B+ 树的叶结点只是存储了数据的地址，故称为非聚集索引。

# 聚簇索引

在 InnoDB 存储引擎表中，每张表都有个主键，如果在创建表时没有显式地定义主键（Primary Key），则 InnoDB 存储引擎会按如下方式选择或创建主键：

- 首先表中是否有非空的唯一索引（Unique NOT NULL），如果有，则该列即为主键。

- 不符合上述条件，InnoDB 存储引擎自动创建一个 6 个字节大小的指针。

# 普通索引

对于字符串类型，可以指定索引前缀长度(且对于 BLOB/TEXT 前缀长度参数是必须的)，在 InnoDB 表中其前缀长度最长是 767 bytes，且参数 M 是用 bytes 计量的。所以太长的字符串，建立 BTree 索引浪费比较大，这时候用手动模拟 HASH 索引是个方法，不过这种方式对字符串无法灵活的使用前缀方式查询(例如 LIKE 这类的操作)。

### Unique Index | 唯一索引

UNIQUE 索引要求索引是唯一的。对于单列索引，要求该列所有数据都不相同，但允许有 NULL 值；对于多列的组合索引，要求这些列的组合是唯一的。UNIQUE 索引其本身既可以作为索引，实际中也可以用以产生数据约束，防止增加或者修改后产生相同数据，从而保证数据的完整性。

# 联合索引

在建立多列索引的时候，必须按照从左到右的顺序使用全部或部分的索引列，才能充分的使用组合索引，比如：(col1, col2, col3)使用(col1)、(col1, col2)、(col1, col2, col3)有效。在查询语句中会一直向右匹配直到遇到范围查询(>,<,BETWEEN,LIKE)就停止匹配，其后的索引列将不会使用索引来优化查找了。

普通索引，对数据没有约束要求，多行记录可以包含相同值。无论对于字符串索引，还是多列组合索引，都以及在查询语句中，都有个最左前缀的原则：

B-Tree 索引可以很好地用于单行、范围或者前缀扫描，他们只有在查找使用了索引的最左前缀（Leftmost Prefix）的时候才有用。不过 B-Tree 索引存在一些限制：

- 如果查找不从索引列的最左边开始，索引就无法使用；同样，不能查找字符串结尾；
- 不能跳过索引中的列；
- 不能使用任何在第一个范围条件右边的列作为条件；

因此 B-Tree 的列顺序非常重要，上述使用规则都和列顺序有关。对于实际的应用，一般要根据具体的需求，创建不同列和不同列顺序的索引。假设有索引 Index(A,B,C):

```sh
# 使用索引
A>5 AND A<10 - 最左前缀匹配
A=5 AND B>6 - 最左前缀匹配
A=5 AND B=6 AND C=7 - 全列匹配
A=5 AND B IN (2,3) AND C>5 - 最左前缀匹配，填坑

# 不能使用索引
B>5 - 没有包含最左前缀
B=6 AND C=7 - 没有包含最左前缀

# 使用部分索引
A>5 AND B=2 - 使用索引 A 列
A=5 AND B>6 AND C=2 - 使用索引的 A 和 B 列
```

使用索引对结果进行排序，需要索引的顺序和 ORDER BY 子句中的顺序一致，并且所有列的升降序一致(ASC/DESC)。如果查询连接了多个表，只有在 ORDER BY 的列引用的是第一个表才可以(需要按序 JOIN)。

```sh
# 使用索引排序
ORDER BY A - 最左前缀匹配
WHERE A=5 ORDER BY B,C - 最左前缀匹配
WHERE A=5 ORDER BY B DESC - 最左前缀匹配
WHERE A>5 ORDER BY A,B - 最左前缀匹配

# 不能使用索引排序
WHERE A=5 ORDER BY B DESC,C ASC - 升降序不一致
WHERE A=5 ORDER BY B,D - D 不在索引中
WHERE A=5 ORDER BY C - 没有包含最左前缀
WHERE A>5 ORDER BY B,C - 第一列是范围条件，无法使用 BC 排序
WHERE A=5 AND B IN(1, 2) ORDER BY C - B 也是范围条件，无法用 C 排序
```

# Primary Key | 主键

主键必须唯一，与索引不同的是不能有 Null，而且一个表只能有一个主键。有很多人认为主键是唯一索引的一种，其实是不准确的。主键也可以是组合索引，只要组合的每条结果是唯一的。这在某些场景非常实用，比如一个多对多关系中的枢纽表就非常适合使用复合主键。在 InnoDB 内部，表数据是优化主键快速查询而排列分布的，其查找速度是最快的(相当于聚簇索引：该索引中键值的逻辑顺序决定了表中相应行的物理顺序)。即使表中没有适合做主键的列，也推荐采用一个自动增长的整数主键(代理键)，那么这个表在增加数据的时候是顺序存放的，而且后续在别的表参考该外键查询的时候也会得到优化。

常见的主键的形式有自增 ID 与 UUID 等，自增的优势在于：

- 唯一性：自增 ID 很容易会被暴力破解，数据迁移的时候，特别是发生表格合并这种操作的时候，会不可避免地存在冲突。UUID 则能够保证唯一性，彻底避免冲突。
- 键长度：自增字段的长度较 UUID 小很多，这会对检索的性能有较大影响。Innodb 引擎进行数据检索时，也是先根据索引找到主键，然后根据主键找到记录；这样在主键长度短的情况下，会有较好的读性能。
- 并发性：自增 ID 并且高并发的情况下，竞争自增锁会降低数据库的吞吐能力。UUID 则能够在应用层生成 UUID，提高数据库的吞吐能力。
- 数据库索引：InnoDB 中表数据是按照主键顺序存放的，在写入数据时候如果发生了随机 IO，那么就会频繁地移动磁盘块。当数据量大的时候，写的短板将非常明显。自增 ID 中新增的数据可以默认按序排列，对于性能有很大的提升；UUID 则主键之间没有顺序规律。

我们建议的方式是使用 Snowflake 算法，在[分布式 ID https://url.wx-coder.cn/tQ5eH](https://url.wx-coder.cn/tQ5eH)部分我们也有详细讨论。

# 链接

- 几篇关于数据库索引的文章 https://ruby-china.org/topics/26352 https://www.cnblogs.com/kenshinobiy/p/4360371.html https://www.cnblogs.com/kenshinobiy/p/4360371.html

- https://www.atatech.org/articles/130831?flag_data_from=mail_daily_group&uid=430792

- https://www.jianshu.com/p/6446c0118427

- https://zhuanlan.zhihu.com/p/23624390

- https://mp.weixin.qq.com/s/Wc6Gw6S5xMy2DhTCrogxVQ
