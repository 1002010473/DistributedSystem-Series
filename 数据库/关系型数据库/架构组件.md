![default](https://user-images.githubusercontent.com/5803001/45228854-de88b400-b2f6-11e8-9ab0-d393ed19f21f.png)

# 关系型数据库中的通用架构组件

值得注意的是，本图并不是严谨的数据库组件的层次架构图，而是对于数据库应该掌握的知识点的总结。

**数据库的核心组件：**

- 过程管理器(The process manager)：数据库都会有一个过程池/线程池需要进行管理。此外，为了使运行时间更短，现代数据库会使用自己的线程来替代操作系统线程。
- 网络管理器(The network manager)：网络的输入输出是个大问题，特别是对于分布式数据库来说。所以部分数据库针对网络管理打造了自己的管理器。
- 文件系统管理器(File system manager)：磁碟 I/O 是数据库的第一瓶颈。使用管理器进行磁碟文件进行管理是很重要的。
- 内存管理器(Memory manager)：当你需要处理大量内存数据或大量查询，一个高效的内存管理器是必须的。
- 安全管理器(Security manager)：进行认证和用户认证管理。
- 客户端管理器(Client manager)：进行客户端连接管理

![图片描述](http://img.blog.csdn.net/20160209193822791)

**数据库的工具：**

备份管理器：进行数据库的备份与恢复

复原管理器：在数据库崩溃后进行数据库重启

监视管理器：进行数据库活动日志记录，同时进行数据库监视

管理员管理器：进行 metadata 存储，管理数据库，表空间，数据泵等

查询管理器：对查询进行有效性检验，优化，编译和执行

数据管理器：包括事务管理器，缓存管理器，数据访问管理器
Promise((resolve, rejct) =>{
f1(cal)
f2(cal); resolove(1);
}

在我撰写 [High-Performance Java Persistence training](https://vladmihalcea.com/trainings/) 一书时，我逐步认识到让读者明白关系型数据库工作原理会是了解如何构建高性能的 Java 持久化存储的重要基石。不过关系型数据库中的事务相关的重要概念：原子性、持久性以及检查点等等也是相当绕人。而本文中我希望以相对高屋建瓴的方式来解释关系型数据库内部工作原理，也会涉及一些数据库实现细节。

![](https://coding.net/u/hoteam/p/Cache/git/raw/master/2017/2/2/datastructuredb.png)

# Data Pages

访问磁盘中的数据往往速度较慢，换言之，内存中数据的访问速度还是远快于 SSD 中的数据访问速度。基于这个考量，基本上所有数据库引擎都尽可能地避免访问磁盘数据。并且无论数据库表还是数据库索引都被划分为了固定大小的数据页(譬如 8 KB)。当我们需要读取表或者索引中的数据时，关系型数据库会将磁盘中的数据页映射入存储缓冲区。当我们需要修改数据时，关系型数据库首先会修改内存页中的数据，然后利用 [fsync](<https://en.wikipedia.org/wiki/Sync_(Unix)>) 这样的同步工具将改变同步回磁盘中。

# Undo log

由于同时可能由多个事务并发地对内存中的数据进行修改，因此关系型数据库往往需要依赖于某个并发控制机制([2PL 或者 MVCC](https://vladmihalcea.com/2017/01/31/a-beginners-guide-to-the-phantom-read-anomaly-and-how-it-differs-between-2pl-and-mvcc/))来保证数据一致性。因此，当某个事务需要去更改数据表中某一行时，未提交的改变会被写入到内存数据中，而之前的数据会被追加写入到 undo log 文件中。

> Oracle 或者 MySQL 中使用了所谓 undo log 数据结构，而 SQL Server 中则是使用 transaction log 完成此项工作。PostgreSQL 并没有 undo log，不过其内建支持所谓多版本的表数据，即同一行的数据可能同时存在多个版本。总而言之，任何关系型数据库都采用的类似的数据结构都是为了允许回滚以及数据的原子性。

如果当前运行的事务发生了回滚，undo log 会被用于重建事务起始阶段时候的内存页。

# Redo Log

某个事务提交之后，内存中的改变就需要同步到磁盘中。不过并不是所有的事务提交都会立刻触发同步，过高频次的同步反而会对应用性能造成损伤。不过根据 [ACID](https://vladmihalcea.com/2014/01/05/a-beginners-guide-to-acid-and-database-transactions/) 原则，提交之后的事务必须要保证持久性，也就是即使此时数据库引擎宕机了，提交之后的更改也应该被持久化存储下来。这里关系型数据库就是依靠 redo log 来达成这一点，它是一个仅允许追加写入的基于磁盘的数据结构，它会记录所有尚未执行同步的事务操作。相较于一次性写入固定数目的数据页到磁盘中，顺序地写入到 redo log 会比随机访问快上很多。因此，关于事务的 ACID 特性的保证与应用性能之间也就达成了较好的平衡。该数据结构在 Oracle 与 MySQL 中就是叫 redo log，而 SQL Server 中则是由 transaction log 执行，在 PostgreSQL 中则是使用 Write-Ahead Log( WAL )。下面我们继续回到上面的那个问题，应该在何时将内存中的数据写入到磁盘中。关系型数据库系统往往使用检查点来同步内存的脏数据页与磁盘中的对应部分。为了避免 IO 阻塞，同步过程往往需要等待较长的时间才能完成。因此，关系型数据库需要保证即使在所有内存脏页同步到磁盘之前引擎就崩溃的时候不会发生数据丢失。同样地，在每次数据库重启的时候，数据库引擎会基于 redo log 重构那些最后一次成功的检查点以来所有的内存数据页。

# 总结

上面我们简要讨论的这些原则与考虑都是为了保证基于磁盘的存储的较高吞吐量的同时保证数据一致性。其中，undo lo 主要用于提供原子性(允许回滚)，而 redo log 则是保证磁盘页的不可变性。

# 数据库组件

![](http://img2.tuicool.com/vI77biF.jpg!web)

数据库是由多种互相交互的组件构成的 。

核心组件 ：

```
进程管理器( process manager ) ：很多数据库具备一个需要妥善管理的 进程/线程池 。再者，为了实现纳秒级操作，一些现代数据库使用自己的线程而不是操作系统线程。
网络管理器( network manager ) ：网路I/O是个大问题，尤其是对于分布式数据库。所以一些数据库具备自己的网络管理器。
文件系统管理器( File system manager ) : 磁盘I/O是数据库的首要瓶颈 。具备一个文件系统管理器来完美地处理OS文件系统甚至取代OS文件系统，是非常重要的。
内存管理器( memory manager ) ：为了避免磁盘I/O带来的性能损失，需要大量的内存。但是如果你要处理大容量内存你需要高效的内存管理器，尤其是你有很多查询同时使用内存的时候。
安全管理器( Security Manager ) ：用于对用户的验证和授权。
客户端管理器( Client manager ) ：用于管理客户端连接。
……
```

工具 ：

```
备份管理器( Backup manager ) ：用于保存和恢复数据。
复原管理器( Recovery manager ) ：用于崩溃后重启数据库到一个 一致状态 。
监控管理器( Monitor manager ) ：用于记录数据库活动信息和提供监控数据库的工具。
Administration 管理器( Administration manager ) ：用于保存元数据(比如表的名称和结构)，提供管理数据库、模式、表空间的工具。 【译者注：好吧，我真的不知道Administration manager该翻译成什么，有知道的麻烦告知，不胜感激……】
……
```

查询管理器 ：

```
查询解析器(Query parser) ：用于检查查询是否合法
查询重写器(Query rewriter) ：用于预优化查询
查询优化器 (Query optimizer) ：用于优化查询
查询执行器 (Query executor) ：用于编译和执行查询
```

数据管理器 ：

```
事务管理器( Transaction manager ) ：用于处理事务
缓存管理器 ( Cache manager ) ：数据被使用之前置于内存，或者数据写入磁盘之前置于内存
数据访问管理器 ( Data access manager ) ：访问磁盘中的数据
```

## 客户端管理器

![图片描述](http://img.blog.csdn.net/20160209194102418)

客户端管理器用于处理和管理客户端的通信。客户端可以是一台服务器或是终端应用。客户端管理器透过不同的 API 来提供访问权，例如：JDBC，ODBC，OLE-DB 等。

当你连接到一个数据库时：

- 管理器会对你的身份和授权进行确认。
- 如果验证通过，会对你的查询请求进行处理。
- 管理器同时会检查数据库是否处于满负荷状态。
- 管理器会等待请求资源的返回。如果发生超时，它会关闭连接并返回可读的错误信息。
- 然后会把你的查询发送给查询管理器，而你的查询是被处理状态。
- 管理器会存储部分结果到缓冲区然后开始进行结果返回。
- 如果出现异常，管理器会中断连接，返回相关原因解释并释放资源。

## 查询管理器

查询管理器是数据库的重要组成部分。其工作过程是：

- 查询会被解释以确认有效性
- 然后会被重写以消除不必要的操作并进行预优化处理
- 然后会被优化处理以提高性能并发送到执行和数据访问计划
- 然后改计划会被编译处理
- 最后进行执行查询

![图片描述](http://img.blog.csdn.net/20160209194441184)

### 查询重写器

重写器的目的是：

1. 进行查询预优化处理
2. 避免不必要的操作
3. 帮助优化器找出最佳方案

**常见的重写规则：**

**视图合并：**如果你在查询中使用了视图，那么该视图会被转换层 SQL 视图代码

**子查询扁平化：**子查询使查询优化变得困难，因此重写器会修改含有子查询的查询以消除子查询。

例如:

![图片描述](http://img.blog.csdn.net/20160209205206311)

会被重写为：

![图片描述](http://img.blog.csdn.net/20160209205221493)

**消除不必要的操作符：**例如当你使用了 UNIQUE 唯一约束而同时使用了 DISTINCT 操作符，那么 DISTINCT 将会被消除。

**多于 JOIN 连接清除：**当你 有两次相同条件的 JOIN 连接但是其中一个条件被隐藏了或者是一个多于的 JOIN，那么它会被清除。

**分区处理：**如果你使用了一个分区表，那么重写器会找出那个分区会被使用。

**自定义规则：**如果你有自定义的查询规则，重写器会执行这些规则。

## 数据管理器

查询管理器的作用是执行查询并对资源发出请求，数据管理器会处理这些请求并返回结果。但这里有两个问题：

- 关系数据库使用的是事务模型。所以你有可能得不到数据，因为其他人可能会正同时使用/修改这些数据。
- 数据获取是数据库中最慢的操作，因此数据管理必须要能高效地获取并数据存放在内存缓冲区。

### 缓存管理器

如前所述，数据库的主要瓶颈是磁碟 I/O。所以现代数据库使用了缓存管理器来提高效率。

查询执行器的数据请求对象是缓存管理器而不是直接的文件系统。缓存管理器有一个内存里缓存叫做缓冲池。从内存获取数据会大大提高数据库速度。

![图片描述](http://img.blog.csdn.net/20160209195818502)

#### 缓冲-替换策略

很多主流数据库(如：SQL Server，MySQL，Oracle 等)使用的是 LRU 算法。

LRU 是 Least Recently Used 的简写，意思最近使用。其理念是缓存最近使用的数据以便再次使用时快速读取。

![图片描述](http://img.blog.csdn.net/20160209195917393)

虽然它有很多优点但也存在不足，比方说表/索引的大小超过了缓冲区大小。因此出现了进阶版本的 LRU，这就是 LRU-K，例如在 SQL Server 使用的是 LRU-K，K=2。在 LRU-K 中：首先考虑数据的 K 次最近使用记录；根据数据的使用次数分配权值；如果有新的数组载入缓存，旧的但经常使用的数据不会被移除，但是当旧数据不再使用，将会被移除，所以权值的设立有助于减少多余数据。

### 事务管理器

事务管理器是为了确保每个查询会执行自己的事务。在讲述事务管理期前，我们需要理解 ACID 事务的概念。

ACID 是一个工作单元，它的意思是：

**Atomicity(原子性)：**事务是”全或全不”的，即使是 10 个小时的事务。如果事务崩溃了，会发生状态回滚。

**Isolation(隔离性)：**如果事务 A 和 B 同时运行，那么事务 A 和 B 的结果必须是一致的，不论 A 对于 B 是完成前/完成后/过程中的状态。

**Durability(耐久性)：**一旦事务完成，数据会存放在数据库中而不论发生什么情况(异常或错误)。

**Consistency(一致性)：**只有有效数据被写入数据库。一致性与原子行和隔离性关联。

#### 并发控制

确保隔离性，附着性和原子性的关键是能对同一数据进行正确写操作(添加，更新和删除)：

如果仅仅是数据读取事务，那么它们可以不与其它修改事务发生冲突；

如果一个修改事务处理的数据被其它事务读取，数据库需要找到方法来隐藏这些修改操作。同时，它需要保证这些修改操作不会被清除。

以上问题就是并发控制。最简单的处理方法是逐个执行事务。但是这不利于进行规模扩张，也无法发挥服务器/CPU 的多核性能。理想的处理方式是每当事务新建或取消时：

监视所有事务的全部操作，检查同时读取/修改相同数据的两个(或多个)事务是否发生冲突

，在发生冲突的事务中进行操作记录以减少冲突部分的大小，把冲突部分以其它次序进行处理，判别某事务是否可以取消

更正规的做法是进行冲突日程表管理。但是在企业级数据库中，是很难为每个新事务事件分配足够多的处理时间。所以会使用其它方法来进行处理。

### 锁管理器

为了处理以上问题，多数数据库会采用锁或数据版本来进行处理。但这是个内容丰富的话题，以下会把讨论重点放在锁部分。

什么是锁呢？

- 事务是否需要数据
- 是否锁定了数据
- 另一事务是否需要相同数据
- 是否不得不等待直至第一个事务释放这些数据

这叫做排斥锁。但是排斥锁针对的对象相同数据的读取和等待，这是不利于资源调配的。还有一种锁，叫共享锁。

在共享锁中：

- 一个事务是否只需读取数据 A
- 共享锁对数据锁定并读取数据
- 如果第二个事务也只需要读取数据 A
- 共享锁对数据锁定并读取数据
- 如果第三个事务只需要修改数据 A
- 那么会对数据进行排斥锁锁定，但它必须等待直至事务一，二释放共享锁才对数据 A 进行排斥锁锁定

![图片描述](http://img.blog.csdn.net/20160209200418122)

锁管理器的作用是提供和释放锁。从内部角度看，它把锁存储在一个有关联的 hash 数据表中。

- 哪些事务锁定了数据
- 哪些事务在等待数据

#### 死锁

锁的存在会导致一个问题：两个事务在无限期地等待数据：

![图片描述](http://img.blog.csdn.net/20160209200455051)

在上图中：

- 事务 A 对数据 1 使用了排斥锁，同时在等待获取数据 2
- 事务 B 对数据 2 使用了排斥是，同时在等待获取数据 1

这就是死锁。

遇到死锁后，锁管理器会选择对哪个事务进行撤销(回滚)以消除死锁。但要进行选择，并不是件容易的事。DB2 和 SQL Sever 使用了两段锁协议(Two-Phase Locking Protocol)来进行处理。

- 在增长段，事务会得到锁，但是不能释放锁。
- 在下降段，事务可释放锁，但是不能得到锁。

![图片描述](http://img.blog.csdn.net/20160209200616796)

其核心理念是：

- 释放不再使用的锁以减少其他事务对这些锁的等待时间
- 避免事务开始后对数据进行修改，所以这是非连贯事务
