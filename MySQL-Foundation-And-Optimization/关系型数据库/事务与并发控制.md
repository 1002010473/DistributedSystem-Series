



> [关系型数据库中事务与并发控制详解]()


# 事务与并发控制



# Transaction: 事务


## ACID


ACID数据库事务极大地简化了应用开发人员的工作.正如其缩写标识所示,ACID事务提供以下几种保证:


- **原子性(Atomicity)**.事务中的所有操作,要么全部成功,要么全部不做.
- **一致性(Consistency)**.在事务开始与结束时,数据库处于一致状态.
- **隔离性(Isolation)**. 事务如同只有这一个操作在被数据库所执行一样.
- **持久性(Durability)**. 在事务结束时,此操作将不可逆转.(也就是只要事务提交,系统将保证数据不会丢失,即使出现系统Crash,译者补充).


对于ACID的实现方式主要有两个，一个是日志式的方式（Write ahead logging），几乎所有的数据库系统（MySQL、Oracle等）都基于日志的方式。另外一种是Shadow paging，代表的数据库主要是SQLite，Android或者iOS APP开发的话应该会比较了解，但大型的数据库都不会用到。
![](http://mmbiz.qpic.cn/mmbiz/Pn4Sm0RsAujF1Uh53H2CzRNHKIzAkSZbyqPPFjQhgY2l6llddIVKZBCkEmoH8VYWO9HRSSZ1RcvmjTPl987CwA/640?wx_fmt=jpeg&wxfrom=5&wx_lazy=1)




数据库厂商在很久以前就认识到数据库分区的必要性,并引入了一种称为2PC(两阶段提交)的技术来提供跨越多个数据库实例的ACID保证.这个协议分为以下两个阶段:


- 第一阶段,事务协调器要求每个涉及到事务的数据库预提交(precommit)此操作,并反映是否可以提交.
- 第二阶段,事务协调器要求每个数据库提交数据.


如果有任何一个数据库否决此次提交,那么所有数据库都会被要求回滚它们在此事务中的那部分信息.这样做的缺陷是什么呢? 我们可以在分区之间获得一致性.如果Brewer的猜测是对的,那么我们一定会影响到可用性,但,怎么可以这样呢?


任何系统的可用性都是执行操作的相关组件的可用性的产物.此陈述的后半段尤其重要.系统中可能会使用但又不是必需的组件,不会降低系统的可用性.在两阶段提交中涉及到两个数据库的事务,它的可用性是这两个数据库中每一个的可用性的产物.例如,如果我们假设每个数据库都有为99.9%的可用性,那么这个事务的可用性就是99.8%,或者说每月43分钟的额外停机时间.


## 隔离级别


　SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。 
- **Read Uncommitted（未提交读）：** 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。**读取未提交的数据，也被称之为脏读（Dirty Read）。**


- **Read Committed（提交读）：**这是大多数数据库系统的默认隔离级别（但不是[MySQL](http://lib.csdn.net/base/14)默认的）。它满足了隔离的简单定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别也支持所谓的**不可重复读（Nonrepeatable Read）**，因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一查询可能返回不同结果。


- **Repeatable Read（可重复读）：**这是MySQL的默认事务隔离级别，它确保在一个事务内的相同查询条件的多次查询会看到同样的数据行，都是事务开始时的数据快照。不过理论上，这会导致另一个棘手的问题：**幻读 （Phantom Read）**，怎么理解幻读？简单说，就是当某个事务在读取某个范围内的记录时， 另外的一个事务又在该范围内插入新的记录。在之前的事务在读取该范围的记录时，就会产生幻行。（InnoDB 通过间隙锁（next-key locking）策略防止幻读的出现）


- **Serializable（可串行化）：**这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。


| 离级别                    | 脏读（Dirty Read） | 不可重复读（NonRepeatable Read） | 幻读（Phantom Read） |
| ---------------------- | -------------- | ------------------------- | ---------------- |
| 未提交读（Read uncommitted） | 可能             | 可能                        | 可能               |
| 提交读（Read committed）    | 不可能            | 可能                        | 可能               |
| 可重复读（Repeatable read）  | 不可能            | 不可能                       | 可能               |
| 可串行化（Serializable ）    | 不可能            | 不可能                       | 不可能              |


### Read uncommitted 读未提交


公司发工资了，领导把5000元打到singo的账号上，但是该事务并未提交，而singo正好去查看账户，发现工资已经到账，是5000元整，非常高兴。可是不幸的是，领导发现发给singo的工资金额不对，是2000元，于是迅速回滚了事务，修改金额后，将事务提交，最后singo实际的工资只有2000元，singo空欢喜一场。


![img](http://dl.iteye.com/upload/attachment/556524/f244ae46-c8f4-3bc1-906e-d1d9c1af3516.gif)


 


出现上述情况，即我们所说的脏读，两个并发的事务，“事务A：领导给singo发工资”、“事务B：singo查询工资账户”，事务B读取了事务A尚未提交的数据。


当隔离级别设置为Read uncommitted时，就可能出现脏读，如何避免脏读，请看下一个隔离级别。


### Read committed 读提交


singo拿着工资卡去消费，系统读取到卡里确实有2000元，而此时她的老婆也正好在网上转账，把singo工资卡的2000元转到另一账户，并在singo之前提交了事务，当singo扣款时，系统检查到singo的工资卡已经没有钱，扣款失败，singo十分纳闷，明明卡里有钱，为何......


出现上述情况，即我们所说的不可重复读，两个并发的事务，“事务A：singo消费”、“事务B：singo的老婆网上转账”，事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。


当隔离级别设置为Read committed时，避免了脏读，但是可能会造成不可重复读。


大多数数据库的默认级别就是Read committed，比如Sql Server , Oracle。如何解决不可重复读这一问题，请看下一个隔离级别。


### Repeatable read 重复读


不可重复读是指事务T1读取数据后，事务T2执行更新操作，使T1无法再现前一次读取结果。具体地讲，不可重复读包括三种情况：

  事务T1读取某一数据后，事务T2对其做了修改，当事务1再次读该数据时，得到与前一次不同的值。例如，T1读取B=100进行运算，T2读取同一数据B，对其进行修改后将B=200写回数据库。T1为了对读取值校对重读B，B已为200，与第一次读取值不一致。

  事务T1按一定条件从数据库中读取了某些数据记录后，事务T2删除了其中部分记录，当T1再次按相同条件读取数据时，发现某些记录神密地消失了。
 事务T1按一定条件从数据库中读取某些数据记录后，事务T2插入了一些记录，当T1再次按相同条件读取数据时，发现多了一些记录。（这也叫做幻影读） 



当隔离级别设置为Repeatable read时，可以避免不可重复读。当singo拿着工资卡去消费时，一旦系统开始读取工资卡信息（即事务开始），singo的老婆就不可能对该记录进行修改，也就是singo的老婆不能在此时转账。


虽然Repeatable read避免了不可重复读，但还有可能出现幻读。


singo的老婆工作在银行部门，她时常通过银行内部系统查看singo的信用卡消费记录。有一天，她正在查询到singo当月信用卡的总消费金额（select sum(amount) from transaction where month = 本月）为80元，而singo此时正好在外面胡吃海塞后在收银台买单，消费1000元，即新增了一条1000元的消费记录（insert transaction ... ），并提交了事务，随后singo的老婆将singo当月信用卡消费的明细打印到A4纸上，却发现消费总额为1080元，singo的老婆很诧异，以为出现了幻觉，幻读就这样产生了。


注：[MySQL](http://lib.csdn.net/base/14)行锁的默认隔离级别就是Repeatable read。


### Serializable 序列化


Serializable是最高的事务隔离级别，同时代价也花费最高，性能很低，一般很少使用，在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻像读。


# Concurrency Control: 并发控制
当多个用户(多事务)同时访问和修改数据的时候，如何能保证用户读取数据的一致性? 我们常常用到一种机制称为：**并发控制(Concurrency Control)** 
　　在大多数据库中，**锁(Lock)** 是并发控制的核心机制之一，锁管理着数据库资源的并发访问，并且防止多用户(多事务) 之间“相互干涉”。下面我们总结一下数据库中常用的锁： 
从对数据操作的类型（读\写）来看分为：


　　**读锁（共享锁）：**针对同一块数据，多个读操作可以同时进行而不会互相影响。


　　**写锁（排他锁）：**当当前写操作没有完成前，它会阻断其他写锁和读锁。 
从锁定的数据范围（锁粒度（Lock granularity））来看分为：


　　**表锁：**管理锁的开销最小，同时允许的并发量也最小的锁机制。MyIsam存储引擎使用的锁机制。当要写入数据时，把整个表都锁上，此时其他读、写动作一律等待。在MySql中，除了MyIsam存储引擎使用这种锁策略外，MySql本身也使用表锁来执行某些特定动作，比如ALTER TABLE.



　　**行锁：**可以支持最大并发的锁策略。InnoDB和Falcon两张存储引擎都采用这种策略。

