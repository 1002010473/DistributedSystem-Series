


# Index:索引
索引允许使用NULL值，并且某个表中某个字段的外键不一定要是目标表的主键。
数据库索引本质上是以增加额外的写操作与用于维护索引数据结构的存储空间为代价的用于提升数据库中数据检索效率的数据结构。索引可以帮助我们快速地定位到数据而不需要每次搜索的时候都遍历数据库中的每一行。我们以MySQL中的真实效率对比为例展示下索引的作用，譬如在我们的employees表中，有大概三十万行的数据:
```
+--------+------------+------------+--------------+--------+------------+
| emp_no | birth_date | first_name | last_name    | gender | hire_date  |
+--------+------------+------------+--------------+--------+------------+
|  10001 | 1953-09-02 | Georgi     | Facello      | M      | 1986-06-26 |
|  10002 | 1964-06-02 | Bezalel    | Simmel       | F      | 1985-11-21 |
|  10003 | 1959-12-03 | Parto      | Bamford      | M      | 1986-08-28 |
|  10004 | 1954-05-01 | Chirstian  | Koblick      | M      | 1986-12-01 |
|  10005 | 1955-01-21 | Kyoichi    | Maliniak     | M      | 1989-09-12 |
|  10006 | 1953-04-20 | Anneke     | Preusig      | F      | 1989-06-02 |
|  10007 | 1957-05-23 | Tzvetan    | Zielinski    | F      | 1989-02-10 |
|  10008 | 1958-02-19 | Saniya     | Kalloufi     | M      | 1994-09-15 |
|  10009 | 1952-04-19 | Sumant     | Peac         | F      | 1985-02-18 |
|  10010 | 1963-06-01 | Duangkaew  | Piveteau     | F      | 1989-08-24 |
|      . |          . | .          | .            | .      | .          |
|      . |          . | .          | .            | .      | .          |
|      . |          . | .          | .            | .      | .          |
| 499999 | 1958-05-01 | Sachin     | Tsukuda      | M      | 1997-11-30 |
| 499998 | 1956-09-05 | Patricia   | Breugel      | M      | 1993-10-13 |
| 499997 | 1961-08-03 | Berhard    | Lenart       | M      | 1986-04-21 |
| 499996 | 1953-03-07 | Zito       | Baaz         | M      | 1990-09-27 |
| 499995 | 1958-09-24 | Dekang     | Lichtner     | F      | 1993-01-12 |
| 499994 | 1952-02-26 | Navin      | Argence      | F      | 1990-04-24 |
| 499993 | 1963-06-04 | DeForest   | Mullainathan | M      | 1997-04-07 |
| 499992 | 1960-10-12 | Siamak     | Salverda     | F      | 1987-05-10 |
| 499991 | 1962-02-26 | Pohua      | Sichman      | F      | 1989-01-12 |
| 499990 | 1963-11-03 | Khaled     | Kohling      | M      | 1985-10-10 |
+--------+------------+------------+--------------+--------+------------+
```
我们想找到first_name为Chirstian的结果，下面比较一下加上索引前后查询所耗费的时间，从结果我们可以看出使用索引可以使查询效率提高20倍。
```
mysql> select * from employees where first_name = 'Chirstian';
mysql> alter table employees add index first_name (first_name);
mysql> select * from employees where first_name = 'Chirstian';
mysql> SHOW PROFILES;
+----------+------------+---------------------------------------------------------+
| Query_ID | Duration   | Query                                                   |
+----------+------------+---------------------------------------------------------+
|        1 | 0.17415400 | select * from employees where first_name = 'Chirstian'  |
|        2 | 1.03130100 | alter table employees add index first_name (first_name) |
|        3 | 0.00869100 | select * from employees where first_name = 'Chirstian'  |
+----------+------------+---------------------------------------------------------+
```


## LSM Tree





LSM读写分离，会优先保证写操作的性能。其数据首先存储内存中，而后需要定期Flush到
硬盘上。
上文中介绍的BTree这种数据库索引方式是传统关系型数据库中主要的索引构建方式，然而BTree通常会存在写操作吞吐量上的瓶颈，其需要大量的磁盘随机IO，很显然，大量的磁盘随机IO会严重影响索引建立的速度。特别地，对于那些索引数据大的情况（例如，两个列的联合索引），插入速度是对性能影响的重要指标，而读取相对来说就比较少。譬如在一个无缓存的情况下，BTree首先需要进行一次磁盘读写将磁盘页读取到内存中，然后进行修改，最后再进行一次IO写回到磁盘中。
LSM-Tree通过内存插入与磁盘的顺序写，来达到最优的写性能，因为这会大大降低磁盘的寻道次数，一次磁盘IO可以写入多个索引块。LSM-tree的主要思想是划分不同等级的树。以两级树为例，可以想象一份索引数据由两个树组成，一棵树存在于内存，一棵树存在于磁盘。内存中的树可以 不一定是B-树，可以是其他的树，例如AVL树。因为数据大小是不同的，没必要牺牲CPU来达到最小的树高度。而存在于磁盘的树是一棵B-树。
![](http://dl.iteye.com/upload/picture/pic/118173/9092b78b-5c7a-37df-b9f2-fb8038bb79b9.jpg)
数据首先会插入到内存中的树。当内存中的树中的数据超过一定阈值时，会进行合并操作。合并操作会从左至右遍历内存中的树的叶子节点与磁盘中的树的叶子节点进行合并，当被合并的数据量达到磁盘的存储页的大小时，会将合并后的数据持久化到磁盘，同时更新父亲节点对叶子节点的指针。
![](http://dl.iteye.com/upload/picture/pic/118175/7ece3749-415a-3083-893e-6859c9b9fc78.jpg)
之前存在于磁盘的叶子节点被合并后，旧的数据并不会被删除，这些数据会拷贝一份和内存中的数据一起顺序写到磁盘。这会操作一些空间的浪费，但是，LSM-tree提供了一些机制来回收这些空间。磁盘中的树的非叶子节点数据也被缓存在内存中。数据查找会首先查找内存中树，如果没有查到结果，会转而查找磁盘中的树。有一个很显然的问题是，如果数据量过于庞大，磁盘中的树相应地也会很大，导致的后果是合并的速度会变慢。一个解决方法是建立各个层次的树，低层次的树都比 上一层次的树数据集大。假设内存中的树为c0, 磁盘中的树按照层次一次为c1, c2, c3, ... ck-1, ck。合并的顺序是(c0, c1), (c1, c2)...(ck-1, ck)。