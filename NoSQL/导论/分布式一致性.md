- [分布式事务：不过是在一致性、吞吐量和复杂度之间，做一个选择](www.primeton.com/read.php?id=2258&his=1)
- [分布式一致性论文阅读阶段性小结](http://blog.fnil.net/blog/ac1fa10ff9b2404ed0b91bdfaf76a87d/)

在分布式系统的同步问题中，我们同样关注于以下几个方面：
- 指令串行化/临界资源管理/锁
- 数据一致性/数据可见性:分布式系统中，锁、事务都是保证数据一致性的重要手段，除此之外，也可以利用譬如一致性协议来保证数据一致性。
- 事务/原子操作:譬如两阶段提交，三阶段提交
分布式系统同步模型中，我们常见的问题表现为临界资源管理与数据一致性，临界资源管理与并发章节中的临界资源管理缘来、解决方案基本一致，而另一个数据一致性问题则与我们在并发环境下讨论的有很大区别。
- [分布式计算——原理、算法和系统](http://o6v08w541.bkt.clouddn.com/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97%E2%80%94%E2%80%94%E5%8E%9F%E7%90%86%E3%80%81%E7%AE%97%E6%B3%95%E5%92%8C%E7%B3%BB%E7%BB%9F.pdf)

从架构的角度来看，业务拆分(数据分区)、数据一致性、性能(可用性)永远是个平衡的艺术：

- 在微服务架构下，为了获得更高的性能与灵活性，将业务应用拆分为多个，交易跨多个微服务编排，数据一致性的问题产生；
- 为了解决数据一致性问题，需要采用不同的事务机制来保障，这又会产生性能(可用性)问题；

在计算机世界里，为了解决一件事情，另外的问题就会接踵而至，从另一个层面印证了IT架构永远是一种平衡的艺术。

“BASE”其核心思想是根据业务特点，采用适当的方式来使系统达到最终一致性(Eventual consistency)；在互联网领域，通常需要**牺牲强一致性来换取系统的高可用性**，只需要保证数据的“最终一致”，只是这个最终时间需要在用户可以接受的范围内；但在金融相关的交易领域，仍然需要采用强一致性的方式来保障交易的准确性与可靠性。


在分布式系统中，为了保证数据的高可用，通常，我们会将数据保留多个副本(replica)，这些副本会放置在不同的物理的机器上。为了对用户提供正确的增\删\改\差等语义，我们需要保证这些放置在不同物理机器上的副本是一致的。
为了解决这种分布式一致性问题，前人在性能和数据一致性的反反复复权衡过程中总结了许多典型的协议和算法。其中比较著名的有二阶提交协议(Two Phase Commitment Protocol)、三阶提交协议(Three Phase Commitment Protocol)和Paxos算法。实际上，分布式锁也可以实现数据一致性，不过其成本太高。

# 数据一致性
分布式领域[CAP理论](http://www.hollischuang.com/archives/666)告诉我们，任何一个分布式系统都无法同时满足Consistency(一致性),Availability(可用性), Partition tolerance(分区容错性) 这三个基本需求。最多只能满足其中两项。 但是，一个分布式系统无论在CAP三者之间如何权衡，都无法彻底放弃一致性(Consistency)，如果真的放弃一致性，那么就说明这个系统中的数据根本不可信，数据也就没有意义，那么这个系统也就没有任何价值可言。所以，无论如何，分布式系统的一致性问题都需要重点关注。([分布式系统的CAP理论](http://www.hollischuang.com/archives/666)、[分布式系统的BASE理论](http://www.hollischuang.com/archives/672))

> 这里先简单提一下，由于一个分布式系统不可能放弃一致性，那么为什么有的架构师还说在某些场景中可以牺牲一致性呢？通常这里说的放弃一致性指的是放弃数据的强一致性(后文介绍什么是强一致性)。

通常情况下，我们所说的分布式一致性问题通常指的是数据一致性问题。那么我们就先来了解一下什么是数据一致性。

## 数据一致性定义与问题由来
数据一致性其实是数据库系统中的概念。我们可以简单的把一致性理解为正确性或者完整性，那么数据一致性通常指关联数据之间的逻辑关系是否正确和完整。我们知道，在数据库系统中通常用事务(访问并可能更新数据库中各种数据项的一个程序执行单元)来保证数据的一致性和完整性。而在分布式系统中，数据一致性往往指的是由于数据的复制，不同数据节点中的数据内容是否完整并且相同。

比如在集中式系统中，有一些关键的配置信息，可以直接保存在服务器的内存中，但是在分布式系统中，如何保存这些配置信息，又如何保证所有机器上的配置信息都保持一致，又如何保证修改一个配置能够把这次修改同步到所有机器中呢？

再比如，在集中式系统中，进行一个同步操作要写同一个数据的时候，可以直接使用事务+锁来管理保证数据的ACID。但是，在分布式系统中如何保证多台机器不会同时写同一条数据呢？

虽然分布式系统有着诸多优点，但是由于采用多机器进行分布式部署的方式提供服务，必然存在着数据的复制。分布式系统的数据复制需求主要来源于以下两个原因：

> 可用性。将数据复制到分布式部署的多台机器中，可以消除单点故障。防止系统由于某台(些)机器宕机导致的不可用。
>
> 性能。通过负载均衡技术，能够让分布在不同地方的数据副本全都对外提供服务。有效提高系统性能。

在分布式系统引入复制机制后，不同的数据节点之间由于网络延时等原因很容易产生数据不一致的情况。复制机制的目的是为了保证数据的一致性。但是数据复制面临的主要难题也是如何保证多个副本之间的数据一致性。

------

假设有这样的场景，有两个人同时去两个不同的火车站买票(A去A火车站，B去B火车站)，为了保证合理的卖票，需要在A火车站和B火车站之间共享关于剩余票数的数据。但是A和B要买的票只剩下一张。一张票当然只能卖给一个人。 如果为了保证系统性能，那么A和B在买票的时候应该都可以买票成功(因为他们在买票过程中余票数据都显示还有一张余票)。两人在买完票之后，系统在做数据复制时发现一张票被卖出了两次，这时就要让A和B两人其中一人手中得票作废掉。这时就要花费很大的力气来通知后买到这张票的人这个消息。。。 如果为了保证数据一致性，那么就需要在A买票的过程中，B只能等着。等A买票结束，并且把余票结果同步到B火车站的售票窗口。然后B才能知道还有没有余票可以购买。

上面的例子可以简单的说明一个系统如果想保证数据一致性很有可能影响其性能。因为并发的写请求需要在前一个写请求结束之后才能进行。

因此，如何能既保证数据一致性，又保证系统的性能，是每一个分布式系统都需要重点考虑和权衡的。一致性模型可以在做这些权衡的时候给我们很多借鉴和思考。

## Reference
- [关于分布式一致性的探究](http://www.hollischuang.com/archives/663)

# 数据一致性模型

### 强一致性

当更新操作完成之后，任何多个后续进程或者线程的访问都会返回最新的更新过的值。这种是对用户最友好的，就是用户上一次写什么，下一次就保证能读到什么。但是这种实现对性能影响较大。

### 弱一致性

系统并不保证续进程或者线程的访问都会返回最新的更新过的值。系统在数据写入成功之后，不承诺立即可以读到最新写入的值，也不会具体的承诺多久之后可以读到。但会尽可能保证在某个时间级别(比如秒级别)之后，可以让数据达到一致性状态。

### 最终一致性

弱一致性的特定形式。系统保证在没有后续更新的前提下，系统最终返回上一次更新操作的值。在没有故障发生的前提下，不一致窗口的时间主要受通信延迟，系统负载和复制副本的个数影响。DNS是一个典型的最终一致性系统。

### 最终一致性模型的变种

> 因果一致性：如果A进程在更新之后向B进程通知更新的完成，那么B的访问操作将会返回更新的值。如果没有因果关系的C进程将会遵循最终一致性的规则。
>
> 读己所写一致性：因果一致性的特定形式。一个进程总可以读到自己更新的数据。
>
> 会话一致性：读己所写一致性的特定形式。进程在访问存储系统同一个会话内，系统保证该进程读己之所写。
>
> 单调读一致性：如果一个进程已经读取到一个特定值，那么该进程不会读取到该值以前的任何值。
>
> 单调写一致性：系统保证对同一个进程的写操作串行化。

上述最终一致性的不同方式可以进行组合，例如单调读一致性和读己之所写一致性就可以组合实现。并且从实践的角度来看，这两者的组合，读取自己更新的 数据，和一旦读取到最新的版本不会再读取旧版本，对于此架构上的程序开发来说，会少很多额外的烦恼。




![](http://www.primeton.com/uploads/image/20160907/20160907103229_58941.png)



# 两阶段/三阶段提交
这种分布式事务解决方案目前在各种技术平台上已经比较成熟：JavaEE架构下面的JTA事务(各应用服务器均提供了实现，Tomcat除外)。

但目前两阶段提交、三阶段提交存在如下的局限性，并不适合在微服务架构体系下使用：

- 所有的操作必须是事务性资源(比如数据库、消息队列、EJB组件等)，存在使用局限性(微服务架构下多数使用HTTP协议)，比较适合传统的单体应用；
- 由于是强一致性，资源需要在事务内部等待，性能影响较大，吞吐率不高，不适合高并发与高性能的业务场景；

# Sagas长事务

在Sagas事务模型中，一个长事务是由一个预先定义好执行顺序的子事务集合和他们对应的补偿子事务集合组成的。典型的一个完整的交易由T1、 T2、……、Tn等多个业务活动组成，每个业务活动可以是本地操作、或者是远程操作，所有的业务活动在Sagas事务下要么全部成功，要么全部回滚，不存 在中间状态。
![](http://www.primeton.com/uploads/image/20160907/20160907103252_67714.png)
   Sagas事务模型的实现机制：
每个业务活动都是一个原子操作；
每个业务活动均提供正反操作；
任何一个业务活动发生错误，按照执行的反顺序，实时执行反操作，进行事务回滚；
回滚失败情况下，需要记录待冲正事务日志，通过重试策略进行重试；
冲正重试依然失败的场景，提供定时冲正服务器，对回滚失败的业务进行定时冲正；
定时冲正依然失败的业务，等待人工干预；
Sagas长事务模型支持对数据一致性要求比较高的场景比较适用，由于采用了补偿的机制，每个原子操作都是先执行任务，避免了长时间的资源锁定，能做到实时释放资源，性能相对有保障。
Sagas长事务方式如果由业务去实现，复杂度与难度并存。在我们实际使用过程中，开发了一套支持Sagas事务模型的框架来支撑业务快速交付。
![](http://www.primeton.com/uploads/image/20160907/20160907103339_41446.png)
   		**开发人员**：业务只需要进行交易编排，每个原子操作提供正反交易；	

		**配置人员**：可以针对异常类型设定事务回滚策略(哪些异常纳入事务管理、哪些异常不纳入事务管理)；每个原子操作的流水是否持久化(为了不同性能可以支持缓存、DB、以及扩展其它持久化方式)；以及冲正选项配置(重试次数、超时时间、是否实时冲正、定时冲正等)；	

		**Sagas事务框架**：提供事务保障机制，负责原子操作的流水落地，原子操作的执行顺序，提供实时冲正、定时冲正、事务拦截器等基础能力；	

		**Sagas框架的核心是IBusinessActivity、IAtomicAction。**IBusinessActivity完成原子活动的enlist()、delist()、prepare()、commit()、rollback()等操作；IAtomicAction主要完成对状态上下文、正反操作执行。	
![](http://www.primeton.com/uploads/image/20160907/20160907103407_44386.png)


