# Casual Consistency | 因果一致性

如果 A 进程在更新之后向 B 进程通知更新的完成，那么 B 的访问操作将会返回更新的值。如果没有因果关系的 C 进程将会遵循最终一致性的规则。因果一致性(Casual Consistency)在一致性的要求上，又比顺序一致性降低了：它仅要求有因果关系的操作顺序得到保证，非因果关系的操作顺序则无所谓。

因果相关的要求是这样的：

- 本地顺序：本进程中，事件执行的顺序即为本地因果顺序。
- 异地顺序：如果读操作返回的是写操作的值，那么该写操作在顺序上一定在读操作之前。
- 闭包传递：和时钟向量里面定义的一样，如果 a->b，b->c，那么肯定也有 a->c。

![](https://i.postimg.cc/MpMvbfpx/image.png)

- 图 a 满足顺序一致性，因此也满足因果一致性，因为从这个系统中的四个进程的角度看，它们都有相同的顺序也有相同的因果关系。

- 图 b 满足因果一致性但是不满足顺序一致性，这是因为从进程 P3、P4 看来，进程 P1、P2 上的操作因果有序，因为 P1、P2 上的写操作不存在因果关系，所以它们可以任意执行。不满足一致性的原因，同上面一样是可以推导出冲突的情况来。

# 案例分析

在 infoq 分享的腾讯朋友圈的设计中，他们在设计数据一致性的时候，使用了因果一致性这个模型。用于保证对同一条朋友圈的回复的一致性，比如这样的情况：

1. A 发了朋友圈内容为梅里雪山的图片。
2. B 针对内容 a 回复了评论：“这里是哪里？”
3. C 针对 B 的评论进行了回复：”这里是梅里雪山“。

那么，这条朋友圈的显示中，显然 C 针对 B 的评论，应该在 B 的评论之后，这是一个因果关系，而其他没有因果关系的数据，可以允许不一致。

微信的做法是：

1. 每个数据中心，都自己生成唯一的、递增的数据 ID，确保能排重。在下图的示例中，有三个数据中心，数据中心 1 生成的数据 ID 模 1 为 0，数据中心 1 生成的数据 ID 模 2 为 0，数据中心 1 生成的数据 ID 模 3 为 0，这样保证了三个数据中心的数据 ID 不会重复全局唯一。
2. 每条评论都比本地看到所有全局 ID 大，这样来确保因果关系，这部分的原理前面提到的向量时钟一样。

![](http://mmbiz.qpic.cn/mmbiz/vxCq1iahXotiaFs84SvDRF5U3gefsfA2F8cp2O082gPUZEbkiawXfogQ3DI8ghhhtFZqicbatRvrklGwxe8JlmrlOw/640?wx_fmt=png&wxfrom=5&wx_lazy=1)

有了这个模型和原理，就很好处理前面针对评论的评论的顺序问题了。

1. 假设 B 在数据中心 1 上，上面的 ID 都满足模 1 为 0，那么当 B 看到 A 的朋友圈时，发表了评论，此时给这个评论分配的 ID 是 1，因此 B 的时钟向量数据是[1]。
2. 假设 C 在数据中心 2 上，上面的 ID 都满足模 2 为 0，当 C 看到了 B 的评论时，针对这个评论做了评论，此时需要给这个评论分配的 ID 肯定要满足模 2 为 0 以及大于 1，评论完毕之后 C 上面的时钟向量是[1,2]。
3. 假设 A 在数据中心 3 上，上面的 ID 都满足模 3 为 0，当 A 看到 B、C 给自己的评论时，很容易按照 ID 进行排序和合并--即使 A 在收到 C 的数据[1,2]之后再收到 B 的数据[1]，也能顺利的完成合并。
