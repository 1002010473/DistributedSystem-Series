# 共识算法

共识是分布式计算中最重要也是最基本的问题之一，所谓共识，就是让所有的节点对某件事达成一致（Get serveral nodes to agree on something）；因为分布式系统中存在着的网络故障与流程故障，可靠地达成共识是一个令人惊讶的棘手问题。一旦达成共识，应用可以将其用于各种目的。共识的典型场景包括了：

- 领导选举：在单主复制的数据库中，所有节点需要就哪个节点是领导者达成一致。如果一些节点由于网络故障而无法与其他节点通信，则可能会对领导权的归属引起争议。在这种情况下，共识对于避免错误的故障切换非常重要。错误的故障切换会导致两个节点都认为自己是领导者。如果有两个领导者，它们都会接受写入，它们的数据会发生分歧，从而导致不一致和数据丢失。

- 原子提交：在支持跨多节点或跨多分区事务的数据库中，一个事务可能在某些节点上失败，但在其他节点上成功。如果我们想要维护事务的原子性，我们必须让所有节点对事务的结果达成一致：要么全部中止/回滚（如果出现任何错误），要么它们全部提交（如果没有出错）。这个共识的例子被称为原子提交（atomic commit）问题。

注意，原子提交的形式化与共识稍有不同：原子事务只有在所有参与者投票提交的情况下才能提交，如果有任何参与者需要中止，则必须中止。 共识则允许就任意一个被参与者提出的候选值达成一致。 然而，原子提交和共识可以相互简化为对方，非阻塞原子提交则要比共识更为困难。

## 共识的不可能性

Fischer，Lynch 和 Paterson 之后的 FLP 结果证明，如果存在节点可能崩溃的风险，则不存在总是能够达成共识的算法。在分布式系统中，我们必须假设节点可能会崩溃，所以可靠的共识是不可能的。然而这里我们正在讨论达成共识的算法，到底是怎么回事？

FLP 结果在异步系统模型中得到了证明（参阅“系统模型与现实”），这是一种限制性很强的模型，它假定确定性算法不能使用任何时钟或超时。如果允许算法使用超时或其他方法来识别可疑的崩溃节点（即使怀疑有时是错误的），则共识变为一个可解的问题。即使仅仅允许算法使用随机数，也足以绕过这个不可能的结果。因此，FLP 是关于共识不可能性的重要理论结果，但现实中的分布式系统通常是可以达成共识的。

---

在分布式事务中我们讨论的两阶段提交（2PC, two-phase commit）算法，这是解决原子提交问题最常见的办法，并在各种数据库、消息队列和应用服务器中实现。事实证明 2PC 是一种共识算法，但不是一个非常好的算法。
