# 共识算法

共识是分布式计算中最重要也是最基本的问题之一，所谓共识，就是让所有的节点对某件事达成一致（Get serveral nodes to agree on something），例如，如果有几个人同时（concurrently）尝试预订飞机上的最后一个座位，或剧院中的同一个座位，或者尝试使用相同的用户名注册一个帐户。共识算法可以用来确定这些互不相容（mutually incompatible）的操作中，哪一个才是赢家。

共识问题通常形式化如下：一个或多个节点可以提议（propose）某些值，而共识算法决定（decides）采用其中的某个值。在座位预订的例子中，当几个顾客同时试图订购最后一个座位时，处理顾客请求的每个节点可以提议正在服务的顾客的 ID，而决定指明了哪个顾客获得了座位。在这种形式下，共识算法必须满足以下性质：

- 一致同意（Uniform agreement）：没有两个节点的决定不同。

- 完整性（Integrity）：没有节点决定两次，一致同意和完整性属性定义了共识的核心思想：所有人都决定了相同的结果，一旦决定了，你就不能改变主意。

- 有效性（Validity）：如果一个节点决定了值 v ，则 v 由某个节点所提议。有效性属性主要是为了排除平凡的解决方案：例如，无论提议了什么值，你都可以有一个始终决定值为 null 的算法；该算法满足一致同意和完整性属性，但不满足有效性属性。

- 终止（Termination） ：由所有未崩溃的节点来最终决定值。如果你不关心容错，那么满足前三个属性很容易：你可以将一个节点硬编码为“独裁者”，并让该节点做出所有的决定。但如果该节点失效，那么系统就无法再做出任何决定。事实上，这就是我们在两阶段提交的情况中所看到的：如果协调者失效，那么存疑的参与者就无法决定提交还是中止。终止属性正式形成了容错的思想。它实质上说的是，一个共识算法不能简单地永远闲坐着等死；换句话说，它必须取得进展。即使部分节点出现故障，其他节点也必须达成一项决定。

## 共识的应用场景

因为分布式系统中存在着的网络故障与流程故障，可靠地达成共识是一个令人惊讶的棘手问题。一旦达成共识，应用可以将其用于各种目的。共识的典型场景包括了：

- 领导选举：在单主复制的数据库中，所有节点需要就哪个节点是领导者达成一致。如果一些节点由于网络故障而无法与其他节点通信，则可能会对领导权的归属引起争议。在这种情况下，共识对于避免错误的故障切换非常重要。错误的故障切换会导致两个节点都认为自己是领导者。如果有两个领导者，它们都会接受写入，它们的数据会发生分歧，从而导致不一致和数据丢失。

- 原子提交：在支持跨多节点或跨多分区事务的数据库中，一个事务可能在某些节点上失败，但在其他节点上成功。如果我们想要维护事务的原子性，我们必须让所有节点对事务的结果达成一致：要么全部中止/回滚（如果出现任何错误），要么它们全部提交（如果没有出错）。这个共识的例子被称为原子提交（atomic commit）问题。

注意，原子提交的形式化与共识稍有不同：原子事务只有在所有参与者投票提交的情况下才能提交，如果有任何参与者需要中止，则必须中止。 共识则允许就任意一个被参与者提出的候选值达成一致。 然而，原子提交和共识可以相互简化为对方，非阻塞原子提交则要比共识更为困难。

## 共识的不可能性

Fischer，Lynch 和 Paterson 之后的 FLP 结果证明，如果存在节点可能崩溃的风险，则不存在总是能够达成共识的算法。在分布式系统中，我们必须假设节点可能会崩溃，所以可靠的共识是不可能的。然而这里我们正在讨论达成共识的算法，到底是怎么回事？

FLP 结果在异步系统模型中得到了证明（参阅“系统模型与现实”），这是一种限制性很强的模型，它假定确定性算法不能使用任何时钟或超时。如果允许算法使用超时或其他方法来识别可疑的崩溃节点（即使怀疑有时是错误的），则共识变为一个可解的问题。即使仅仅允许算法使用随机数，也足以绕过这个不可能的结果。因此，FLP 是关于共识不可能性的重要理论结果，但现实中的分布式系统通常是可以达成共识的。

---

在分布式事务中我们讨论的两阶段提交（2PC, two-phase commit）算法，这是解决原子提交问题最常见的办法，并在各种数据库、消息队列和应用服务器中实现。事实证明 2PC 是一种共识算法，但不是一个非常好的算法。
